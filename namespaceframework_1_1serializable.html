<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.2-20121118"/>
<title>framework: framework::serializable Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2-20121118 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceframework.html">framework</a></li><li class="navelem"><a class="el" href="namespaceframework_1_1serializable.html">serializable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">framework::serializable Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Serializable namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__default__specification.html">serializable_default_specification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default container serializer.  <a href="structframework_1_1serializable_1_1serializable__default__specification.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification.html">serializable_specification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializable specification.  <a href="structframework_1_1serializable_1_1serializable__specification.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__default__serializable.html">is_default_serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default serializable type trait.  <a href="structframework_1_1serializable_1_1is__default__serializable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01stb66d2d131f030bac4477bfabefb1658b.html">serializable_default_specification&lt; T, typename std::enable_if&lt; !is_default_serializable&lt; T &gt;::value &amp;&amp;std::is_fundamental&lt; T &gt;::value, void &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default specification for fundamental types.  <a href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01stb66d2d131f030bac4477bfabefb1658b.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01st5a8093b8b5f11f424afd66f96f3f7753.html">serializable_default_specification&lt; T, typename std::enable_if&lt; !std::is_fundamental&lt; T &gt;::value &amp;&amp;!is_default_serializable&lt; T &gt;::value, void &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default specialization for types missing a <em>required</em> specification.  <a href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01st5a8093b8b5f11f424afd66f96f3f7753.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1container__type.html">container_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__default__container__serializable.html">is_default_container_serializable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__default__serializable_3_01T_00_01typename_01std_1_1enable795a3c7676e1a8bf79bb0208a354885b.html">is_default_serializable&lt; T, typename std::enable_if&lt; is_default_container_serializable&lt; T &gt;::value, void &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__container__type.html">is_container_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1get__container__specification.html">get_container_specification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get specification.  <a href="structframework_1_1serializable_1_1get__container__specification.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1get__container__children.html">get_container_children</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get children.  <a href="structframework_1_1serializable_1_1get__container__children.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01sta3790cff9010baf84408e8f1f60d4002.html">serializable_default_specification&lt; T, typename std::enable_if&lt; is_default_container_serializable&lt; T &gt;::value, void &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <code><a class="el" href="structframework_1_1serializable_1_1container__type.html">container_type</a></code> specification.  <a href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01sta3790cff9010baf84408e8f1f60d4002.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializable alias wrapper.  <a href="structframework_1_1serializable_1_1alias.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1optional__field__input__wrapper.html">optional_field_input_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional field input stream wrapper.  <a href="classframework_1_1serializable_1_1optional__field__input__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1optional__field__output__wrapper.html">optional_field_output_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional field output stream wrapper.  <a href="classframework_1_1serializable_1_1optional__field__output__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1optional__field.html">optional_field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional field container.  <a href="structframework_1_1serializable_1_1optional__field.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification_3_01optional__field_3_01Type_00_01Specification_8_8_8_4_01_4.html">serializable_specification&lt; optional_field&lt; Type, Specification...&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional field serialization implementation.  <a href="structframework_1_1serializable_1_1serializable__specification_3_01optional__field_3_01Type_00_01Specification_8_8_8_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1optional__value__implementation.html">optional_value_implementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional value implementation.  <a href="structframework_1_1serializable_1_1optional__value__implementation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1optional__value.html">optional_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional value container.  <a href="structframework_1_1serializable_1_1optional__value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification_3_01optional__value_3_01Flag_00_059bd789c6599aab6021debf6c4f3dcf0.html">serializable_specification&lt; optional_value&lt; Flag, Name, Specification, Implementation &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional value serialization.  <a href="structframework_1_1serializable_1_1serializable__specification_3_01optional__value_3_01Flag_00_059bd789c6599aab6021debf6c4f3dcf0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1value__implementation__wrapper.html">value_implementation_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation wrapper.  <a href="structframework_1_1serializable_1_1value__implementation__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1value__implementation.html">value_implementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation.  <a href="structframework_1_1serializable_1_1value__implementation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1value.html">value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value container.  <a href="structframework_1_1serializable_1_1value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">exception &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exceptionframework_1_1serializable_1_1inline__object.html">inline_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline object wrapper.  <a href="exceptionframework_1_1serializable_1_1inline__object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1mutator__type.html">mutator_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__mutator__type.html">is_mutator_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1get__mutator__child.html">get_mutator_child</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutator type extractor.  <a href="structframework_1_1serializable_1_1type__extractor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1big__endian.html">big_endian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification_3_01big__endian_3_01T_01_4_01_4.html">serializable_specification&lt; big_endian&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structframework_1_1serializable_1_1big__endian.html">big_endian</a></code> serialization.  <a href="structframework_1_1serializable_1_1serializable__specification_3_01big__endian_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1fixed__container.html">fixed_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification_3_01fixed__container_3_01Value_00_01Container_01_4_01_4.html">serializable_specification&lt; fixed_container&lt; Value, Container &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structframework_1_1serializable_1_1fixed__container.html">fixed_container</a></code> serialization.  <a href="structframework_1_1serializable_1_1serializable__specification_3_01fixed__container_3_01Value_00_01Container_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification_3_01little__endian_3_01T_01_4_01_4.html">serializable_specification&lt; little_endian&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a></code> serialization.  <a href="structframework_1_1serializable_1_1serializable__specification_3_01little__endian_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1terminated.html">terminated</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification_3_01terminated_3_01Value_00_01Tere7f2be436bccdd72b5c15c4f1c2efbd5.html">serializable_specification&lt; terminated&lt; Value, Terminator, Container &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>terminated</code> serialization.  <a href="structframework_1_1serializable_1_1serializable__specification_3_01terminated_3_01Value_00_01Tere7f2be436bccdd72b5c15c4f1c2efbd5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification_3_01tuple__container_3_01pack__co0cf50851bfa90de9c04cb992045c6093.html">serializable_specification&lt; tuple_container&lt; pack_container&lt; Parameters...&gt;, Container &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a></code> serialization.  <a href="structframework_1_1serializable_1_1serializable__specification_3_01tuple__container_3_01pack__co0cf50851bfa90de9c04cb992045c6093.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__specification_3_01variable__container_3_01Size_6255bb7d1b82ea56e7dd8a58c39874d4.html">serializable_specification&lt; variable_container&lt; Size, Value, Container &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a></code> serialization.  <a href="structframework_1_1serializable_1_1serializable__specification_3_01variable__container_3_01Size_6255bb7d1b82ea56e7dd8a58c39874d4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html">serializable_implementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializable implementation.  <a href="classframework_1_1serializable_1_1serializable__implementation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1extract__values.html">extract_values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts value types.  <a href="structframework_1_1serializable_1_1extract__values.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__derived__type.html">is_derived_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__default__derived__serializable.html">is_default_derived_serializable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__default__serializable_3_01T_00_01typename_01std_1_1enable3b6c41d8b7b724cced9b62d14f506375.html">is_default_serializable&lt; T, typename std::enable_if&lt; is_default_derived_serializable&lt; T &gt;::value, void &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1get__base.html">get_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets base type.  <a href="structframework_1_1serializable_1_1get__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1get__visible__names.html">get_visible_names</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get visible names.  <a href="structframework_1_1serializable_1_1get__visible__names.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01st111c2a9cd42f62934e8e174cc07a940a.html">serializable_default_specification&lt; T, typename std::enable_if&lt; is_default_derived_serializable&lt; T &gt;::value, void &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <code>derived</code> type specification.  <a href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01st111c2a9cd42f62934e8e174cc07a940a.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1comparable.html">comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparable template.  <a href="structframework_1_1serializable_1_1comparable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1value__type.html">value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__value__type.html">is_value_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>T</code> is a value type.  <a href="structframework_1_1serializable_1_1is__value__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1get__value__name.html">get_value_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name.  <a href="structframework_1_1serializable_1_1get__value__name.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1get__value__specification.html">get_value_specification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get specification.  <a href="structframework_1_1serializable_1_1get__value__specification.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1get__value__implementation.html">get_value_implementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get implementation.  <a href="structframework_1_1serializable_1_1get__value__implementation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__default__value__serializable.html">is_default_value_serializable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1is__default__serializable_3_01T_00_01typename_01std_1_1enabled84e813e58fea4019add314379560703.html">is_default_serializable&lt; T, typename std::enable_if&lt; is_default_value_serializable&lt; T &gt;::value, void &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01st885ffc55f0111af41318aa866da172ed.html">serializable_default_specification&lt; T, typename std::enable_if&lt; is_default_value_serializable&lt; T &gt;::value, void &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <code><a class="el" href="structframework_1_1serializable_1_1value__type.html">value_type</a></code> specification.  <a href="structframework_1_1serializable_1_1serializable__default__specification_3_01T_00_01typename_01st885ffc55f0111af41318aa866da172ed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a93c99485d1da775955c9f210067bd5d1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93c99485d1da775955c9f210067bd5d1"></a>
template&lt;std::size_t Size, typename Value &gt; </td></tr>
<tr class="memitem:a93c99485d1da775955c9f210067bd5d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a93c99485d1da775955c9f210067bd5d1">stl_array</a> = <a class="el" href="structframework_1_1serializable_1_1fixed__container.html">fixed_container</a>&lt; Value, std::array&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, Size &gt;&gt;</td></tr>
<tr class="memdesc:a93c99485d1da775955c9f210067bd5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL array specification. <br/></td></tr>
<tr class="separator:a93c99485d1da775955c9f210067bd5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac885687ed2a97c405ef04ce26c52bcf8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac885687ed2a97c405ef04ce26c52bcf8"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:ac885687ed2a97c405ef04ce26c52bcf8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ac885687ed2a97c405ef04ce26c52bcf8">stl_deque</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::deque&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:ac885687ed2a97c405ef04ce26c52bcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL deque specification. <br/></td></tr>
<tr class="separator:ac885687ed2a97c405ef04ce26c52bcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfe513049c0929ea741ea79fe04d901"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1dfe513049c0929ea741ea79fe04d901"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a1dfe513049c0929ea741ea79fe04d901"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a1dfe513049c0929ea741ea79fe04d901">stl_forward_list</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::forward_list&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a1dfe513049c0929ea741ea79fe04d901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL forward list specification. <br/></td></tr>
<tr class="separator:a1dfe513049c0929ea741ea79fe04d901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973528309530bf6722e1b8d32aeca077"><td class="memTemplParams" colspan="2"><a class="anchor" id="a973528309530bf6722e1b8d32aeca077"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a973528309530bf6722e1b8d32aeca077"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a973528309530bf6722e1b8d32aeca077">stl_list</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::list&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a973528309530bf6722e1b8d32aeca077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL list specification. <br/></td></tr>
<tr class="separator:a973528309530bf6722e1b8d32aeca077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16f001118e0733e530161b8a8ccde20"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad16f001118e0733e530161b8a8ccde20"></a>
template&lt;typename Size , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad16f001118e0733e530161b8a8ccde20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ad16f001118e0733e530161b8a8ccde20">stl_map</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a117425e721f4fee8c9b77347084c249f">stl_pair</a>&lt; T1, T2 &gt;, std::map&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T1 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T2 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:ad16f001118e0733e530161b8a8ccde20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL map specification. <br/></td></tr>
<tr class="separator:ad16f001118e0733e530161b8a8ccde20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04a84fc4afd9a1ca6c3a425459f81e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae04a84fc4afd9a1ca6c3a425459f81e1"></a>
template&lt;typename Size , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae04a84fc4afd9a1ca6c3a425459f81e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ae04a84fc4afd9a1ca6c3a425459f81e1">stl_multimap</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a117425e721f4fee8c9b77347084c249f">stl_pair</a>&lt; T1, T2 &gt;, std::multimap&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T1 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T2 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:ae04a84fc4afd9a1ca6c3a425459f81e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL multimap specification. <br/></td></tr>
<tr class="separator:ae04a84fc4afd9a1ca6c3a425459f81e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117425e721f4fee8c9b77347084c249f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a117425e721f4fee8c9b77347084c249f"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a117425e721f4fee8c9b77347084c249f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a117425e721f4fee8c9b77347084c249f">stl_pair</a> = <a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a>&lt; <a class="el" href="structframework_1_1pack__container.html">pack_container</a>&lt; T1, T2 &gt;, std::pair&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T1 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T2 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a117425e721f4fee8c9b77347084c249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL pair specification. <br/></td></tr>
<tr class="separator:a117425e721f4fee8c9b77347084c249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fa68c580c5ebbf060a6a31c0b18361"><td class="memTemplParams" colspan="2"><a class="anchor" id="a66fa68c580c5ebbf060a6a31c0b18361"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a66fa68c580c5ebbf060a6a31c0b18361"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a66fa68c580c5ebbf060a6a31c0b18361">stl_set</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::set&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a66fa68c580c5ebbf060a6a31c0b18361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL set specification. <br/></td></tr>
<tr class="separator:a66fa68c580c5ebbf060a6a31c0b18361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a6d010d37ea865ec4501e785b52f82"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56a6d010d37ea865ec4501e785b52f82"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a56a6d010d37ea865ec4501e785b52f82"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a56a6d010d37ea865ec4501e785b52f82">stl_multiset</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::multiset&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a56a6d010d37ea865ec4501e785b52f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL multiset specification. <br/></td></tr>
<tr class="separator:a56a6d010d37ea865ec4501e785b52f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630701062764119d627e50e863e4d5e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a630701062764119d627e50e863e4d5e0"></a>
template&lt;typename Size &gt; </td></tr>
<tr class="memitem:a630701062764119d627e50e863e4d5e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a630701062764119d627e50e863e4d5e0">stl_string</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, char, std::string &gt;</td></tr>
<tr class="memdesc:a630701062764119d627e50e863e4d5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL string specification. <br/></td></tr>
<tr class="separator:a630701062764119d627e50e863e4d5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe4dd751b45a97c4651ab711fb24bac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbe4dd751b45a97c4651ab711fb24bac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#afbe4dd751b45a97c4651ab711fb24bac">stl_null_string</a> = <a class="el" href="structframework_1_1serializable_1_1terminated.html">terminated</a>&lt; char, '\0', std::string &gt;</td></tr>
<tr class="memdesc:afbe4dd751b45a97c4651ab711fb24bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL string specification, null terminated. <br/></td></tr>
<tr class="separator:afbe4dd751b45a97c4651ab711fb24bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f51cdf6a41c7cc40fbe951b0da49823"><td class="memTemplParams" colspan="2">template&lt;typename Size &gt; </td></tr>
<tr class="memitem:a0f51cdf6a41c7cc40fbe951b0da49823"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a0f51cdf6a41c7cc40fbe951b0da49823">stl_wstring</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a>&lt; wchar_t &gt;, std::wstring &gt;</td></tr>
<tr class="memdesc:a0f51cdf6a41c7cc40fbe951b0da49823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL wstring specification.  <a href="#a0f51cdf6a41c7cc40fbe951b0da49823"></a><br/></td></tr>
<tr class="separator:a0f51cdf6a41c7cc40fbe951b0da49823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a96f38544936b70b651359070505ff9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a6a96f38544936b70b651359070505ff9">stl_null_wstring</a> = <a class="el" href="structframework_1_1serializable_1_1terminated.html">terminated</a>&lt; <a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a>&lt; wchar_t &gt;, L'\0', std::wstring &gt;</td></tr>
<tr class="memdesc:a6a96f38544936b70b651359070505ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL wstring specification, null terminated.  <a href="#a6a96f38544936b70b651359070505ff9"></a><br/></td></tr>
<tr class="separator:a6a96f38544936b70b651359070505ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d621c5ef8ab3f20d3d11e83f2427a5a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d621c5ef8ab3f20d3d11e83f2427a5a"></a>
template&lt;typename Size , typename CharT , typename Traits  = std::char_traits &lt;typename type_extractor &lt;CharT&gt;::type&gt;, typename Allocator  = std::allocator &lt;typename type_extractor &lt;CharT&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:a6d621c5ef8ab3f20d3d11e83f2427a5a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a6d621c5ef8ab3f20d3d11e83f2427a5a">stl_basic_string</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; CharT &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, std::basic_string&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; CharT &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, Traits, Allocator &gt;&gt;</td></tr>
<tr class="memdesc:a6d621c5ef8ab3f20d3d11e83f2427a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL basic string specification. <br/></td></tr>
<tr class="separator:a6d621c5ef8ab3f20d3d11e83f2427a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10f41b463081b757c56317ffd25a21f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac10f41b463081b757c56317ffd25a21f"></a>
template&lt;typename CharT , typename Traits  = std::char_traits &lt;typename type_extractor &lt;CharT&gt;::type&gt;, typename Allocator  = std::allocator &lt;typename type_extractor &lt;CharT&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:ac10f41b463081b757c56317ffd25a21f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ac10f41b463081b757c56317ffd25a21f">stl_null_basic_string</a> = <a class="el" href="structframework_1_1serializable_1_1terminated.html">terminated</a>&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; CharT &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, static_cast&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; CharT &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;(0), std::basic_string&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; CharT &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, Traits, Allocator &gt;&gt;</td></tr>
<tr class="memdesc:ac10f41b463081b757c56317ffd25a21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL basic string specification, null terminated. <br/></td></tr>
<tr class="separator:ac10f41b463081b757c56317ffd25a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724e890387728b197847969a7c0d9c16"><td class="memTemplParams" colspan="2"><a class="anchor" id="a724e890387728b197847969a7c0d9c16"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a724e890387728b197847969a7c0d9c16"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a724e890387728b197847969a7c0d9c16">stl_tuple</a> = <a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a>&lt; <a class="el" href="structframework_1_1pack__container.html">pack_container</a>&lt; Types...&gt;, std::tuple&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Types &gt;::type...&gt;&gt;</td></tr>
<tr class="memdesc:a724e890387728b197847969a7c0d9c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL tuple specification. <br/></td></tr>
<tr class="separator:a724e890387728b197847969a7c0d9c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d0d47c45e5de174bfa12be279ee7f2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04d0d47c45e5de174bfa12be279ee7f2"></a>
template&lt;typename Size , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a04d0d47c45e5de174bfa12be279ee7f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a04d0d47c45e5de174bfa12be279ee7f2">stl_unordered_map</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a117425e721f4fee8c9b77347084c249f">stl_pair</a>&lt; T1, T2 &gt;, std::unordered_map&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T1 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T2 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a04d0d47c45e5de174bfa12be279ee7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL map specification. <br/></td></tr>
<tr class="separator:a04d0d47c45e5de174bfa12be279ee7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ace7f819184691ffaab7b2aea90344a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ace7f819184691ffaab7b2aea90344a"></a>
template&lt;typename Size , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6ace7f819184691ffaab7b2aea90344a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a6ace7f819184691ffaab7b2aea90344a">stl_unordered_multimap</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a117425e721f4fee8c9b77347084c249f">stl_pair</a>&lt; T1, T2 &gt;, std::unordered_multimap&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T1 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; T2 &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a6ace7f819184691ffaab7b2aea90344a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL multimap specification. <br/></td></tr>
<tr class="separator:a6ace7f819184691ffaab7b2aea90344a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66c407352fa9a1433c8713e4aa3ea7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c66c407352fa9a1433c8713e4aa3ea7"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a3c66c407352fa9a1433c8713e4aa3ea7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a3c66c407352fa9a1433c8713e4aa3ea7">stl_unordered_set</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::unordered_set&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:a3c66c407352fa9a1433c8713e4aa3ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL set specification. <br/></td></tr>
<tr class="separator:a3c66c407352fa9a1433c8713e4aa3ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0d6756b0f1c44388b844c5d9679fec"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd0d6756b0f1c44388b844c5d9679fec"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:acd0d6756b0f1c44388b844c5d9679fec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#acd0d6756b0f1c44388b844c5d9679fec">stl_unordered_multiset</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::unordered_multiset&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:acd0d6756b0f1c44388b844c5d9679fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL multiset specification. <br/></td></tr>
<tr class="separator:acd0d6756b0f1c44388b844c5d9679fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1165ac58826c0beecfe3d64052c74dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1165ac58826c0beecfe3d64052c74dc"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:ae1165ac58826c0beecfe3d64052c74dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ae1165ac58826c0beecfe3d64052c74dc">stl_vector</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::vector&lt; typename <a class="el" href="structframework_1_1serializable_1_1type__extractor.html">type_extractor</a>&lt; Value &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;&gt;</td></tr>
<tr class="memdesc:ae1165ac58826c0beecfe3d64052c74dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL vector specification. <br/></td></tr>
<tr class="separator:ae1165ac58826c0beecfe3d64052c74dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a77276bf43db604807844d1cde1562"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Specification&gt; </td></tr>
<tr class="memitem:af3a77276bf43db604807844d1cde1562"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562">serializable</a> = <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html">serializable_implementation</a>&lt; Derived, <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, typename <a class="el" href="structframework_1_1serializable_1_1extract__values.html">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="structframework_1_1serializable_1_1get__container__specification.html">get_container_specification</a> &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1extract__values.html">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="structframework_1_1serializable_1_1get__container__children.html">get_container_children</a> &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1extract__values.html">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="structframework_1_1serializable_1_1get__container__children.html">get_container_children</a> &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &gt;</td></tr>
<tr class="memdesc:af3a77276bf43db604807844d1cde1562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation alias.  <a href="#af3a77276bf43db604807844d1cde1562"></a><br/></td></tr>
<tr class="separator:af3a77276bf43db604807844d1cde1562"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a116938beb8e2e5e17ac3029a7b5c2e60"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a116938beb8e2e5e17ac3029a7b5c2e60"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a116938beb8e2e5e17ac3029a7b5c2e60">read</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:a116938beb8e2e5e17ac3029a7b5c2e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read fowarder.  <a href="#a116938beb8e2e5e17ac3029a7b5c2e60"></a><br/></td></tr>
<tr class="separator:a116938beb8e2e5e17ac3029a7b5c2e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b0af2f2f45ba69a1d6b7c7fc2dbb5e"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a99b0af2f2f45ba69a1d6b7c7fc2dbb5e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a99b0af2f2f45ba69a1d6b7c7fc2dbb5e">write</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:a99b0af2f2f45ba69a1d6b7c7fc2dbb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write forwarder.  <a href="#a99b0af2f2f45ba69a1d6b7c7fc2dbb5e"></a><br/></td></tr>
<tr class="separator:a99b0af2f2f45ba69a1d6b7c7fc2dbb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e424c9a7e9c6032083bd6b28a1a18ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e424c9a7e9c6032083bd6b28a1a18ca"></a>
template&lt;typename Name , typename Object , typename... Args&gt; </td></tr>
<tr class="memitem:a9e424c9a7e9c6032083bd6b28a1a18ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a9e424c9a7e9c6032083bd6b28a1a18ca">get</a> (Object const &amp;t, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a581563a786db60888b617c700dc0a8b8">interface</a>&lt; Name &gt;(t).get(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a9e424c9a7e9c6032083bd6b28a1a18ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get. <br/></td></tr>
<tr class="separator:a9e424c9a7e9c6032083bd6b28a1a18ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739eef06f5db7c8ed56fdcdaa25bed82"><td class="memTemplParams" colspan="2"><a class="anchor" id="a739eef06f5db7c8ed56fdcdaa25bed82"></a>
template&lt;typename Name , typename Object , typename... Args&gt; </td></tr>
<tr class="memitem:a739eef06f5db7c8ed56fdcdaa25bed82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a739eef06f5db7c8ed56fdcdaa25bed82">set</a> (Object &amp;t, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a581563a786db60888b617c700dc0a8b8">interface</a>&lt; Name &gt;(t).set(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a739eef06f5db7c8ed56fdcdaa25bed82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set. <br/></td></tr>
<tr class="separator:a739eef06f5db7c8ed56fdcdaa25bed82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a548383ba8cdc2f9efdf2f26d23c4ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9a548383ba8cdc2f9efdf2f26d23c4ed"></a>
template&lt;typename Name , typename Object , typename... Args&gt; </td></tr>
<tr class="memitem:a9a548383ba8cdc2f9efdf2f26d23c4ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a9a548383ba8cdc2f9efdf2f26d23c4ed">check</a> (Object const &amp;t, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a581563a786db60888b617c700dc0a8b8">interface</a>&lt; Name &gt;(t).check(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a9a548383ba8cdc2f9efdf2f26d23c4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check. <br/></td></tr>
<tr class="separator:a9a548383ba8cdc2f9efdf2f26d23c4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0716c4a8b5c61a4eafbab8314a1edbba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0716c4a8b5c61a4eafbab8314a1edbba"></a>
template&lt;typename Name , typename Object , typename... Args&gt; </td></tr>
<tr class="memitem:a0716c4a8b5c61a4eafbab8314a1edbba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a0716c4a8b5c61a4eafbab8314a1edbba">clear</a> (Object &amp;t, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a581563a786db60888b617c700dc0a8b8">interface</a>&lt; Name &gt;(t).clear(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a0716c4a8b5c61a4eafbab8314a1edbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear. <br/></td></tr>
<tr class="separator:a0716c4a8b5c61a4eafbab8314a1edbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9b390782cfcdff51c7720f693a0771"><td class="memTemplParams" colspan="2"><a class="anchor" id="acb9b390782cfcdff51c7720f693a0771"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:acb9b390782cfcdff51c7720f693a0771"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#acb9b390782cfcdff51c7720f693a0771">less</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:acb9b390782cfcdff51c7720f693a0771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than. <br/></td></tr>
<tr class="separator:acb9b390782cfcdff51c7720f693a0771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e48a8ad6b93a66562bddc89598d1f9e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e48a8ad6b93a66562bddc89598d1f9e"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:a6e48a8ad6b93a66562bddc89598d1f9e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a6e48a8ad6b93a66562bddc89598d1f9e">greater</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:a6e48a8ad6b93a66562bddc89598d1f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than. <br/></td></tr>
<tr class="separator:a6e48a8ad6b93a66562bddc89598d1f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af691f7bacf52c26ae993f292ce30a111"><td class="memTemplParams" colspan="2"><a class="anchor" id="af691f7bacf52c26ae993f292ce30a111"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:af691f7bacf52c26ae993f292ce30a111"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#af691f7bacf52c26ae993f292ce30a111">less_or_equal</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:af691f7bacf52c26ae993f292ce30a111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to. <br/></td></tr>
<tr class="separator:af691f7bacf52c26ae993f292ce30a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaba6758e294eb5e5961d9779a60fc16"><td class="memTemplParams" colspan="2"><a class="anchor" id="adaba6758e294eb5e5961d9779a60fc16"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:adaba6758e294eb5e5961d9779a60fc16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#adaba6758e294eb5e5961d9779a60fc16">greater_or_equal</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:adaba6758e294eb5e5961d9779a60fc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to. <br/></td></tr>
<tr class="separator:adaba6758e294eb5e5961d9779a60fc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff20e54f2382945ad4baba087867d110"><td class="memTemplParams" colspan="2"><a class="anchor" id="aff20e54f2382945ad4baba087867d110"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:aff20e54f2382945ad4baba087867d110"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#aff20e54f2382945ad4baba087867d110">equal</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:aff20e54f2382945ad4baba087867d110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to. <br/></td></tr>
<tr class="separator:aff20e54f2382945ad4baba087867d110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552ed9aec8f29fcfc6f532c59403622a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a552ed9aec8f29fcfc6f532c59403622a"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:a552ed9aec8f29fcfc6f532c59403622a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a552ed9aec8f29fcfc6f532c59403622a">not_equal</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:a552ed9aec8f29fcfc6f532c59403622a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal. <br/></td></tr>
<tr class="separator:a552ed9aec8f29fcfc6f532c59403622a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581563a786db60888b617c700dc0a8b8"><td class="memTemplParams" colspan="2">template&lt;typename Name , typename Object &gt; </td></tr>
<tr class="memitem:a581563a786db60888b617c700dc0a8b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a581563a786db60888b617c700dc0a8b8">interface</a> (Object &amp;t) -&gt; typename <a class="el" href="structframework_1_1serializable_1_1get__base.html">get_base</a>&lt; Object, Name &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> &amp;</td></tr>
<tr class="separator:a581563a786db60888b617c700dc0a8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780ec860d7f9b91ee52b165e80fd8195"><td class="memTemplParams" colspan="2">template&lt;typename Name , typename Object &gt; </td></tr>
<tr class="memitem:a780ec860d7f9b91ee52b165e80fd8195"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a780ec860d7f9b91ee52b165e80fd8195">interface</a> (Object const &amp;t) -&gt; typename <a class="el" href="structframework_1_1serializable_1_1get__base.html">get_base</a>&lt; Object, Name &gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a> const &amp;</td></tr>
<tr class="separator:a780ec860d7f9b91ee52b165e80fd8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Serializable namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af3a77276bf43db604807844d1cde1562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Specification&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562">framework::serializable::serializable</a> = typedef <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html">serializable_implementation</a> &lt; Derived, <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, typename <a class="el" href="structframework_1_1serializable_1_1extract__values.html">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="structframework_1_1serializable_1_1get__container__specification.html">get_container_specification</a>&gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1extract__values.html">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="structframework_1_1serializable_1_1get__container__children.html">get_container_children</a>&gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>, typename <a class="el" href="structframework_1_1serializable_1_1extract__values.html">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="structframework_1_1serializable_1_1get__container__children.html">get_container_children</a>&gt;::<a class="el" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3">type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation alias. </p>
<p>Default <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html" title="Serializable implementation.">serializable_implementation</a> alias.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>derived class </td></tr>
    <tr><td class="paramname">Specification</td><td>child types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a96f38544936b70b651359070505ff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a6a96f38544936b70b651359070505ff9">framework::serializable::stl_null_wstring</a> = typedef <a class="el" href="structframework_1_1serializable_1_1terminated.html">terminated</a> &lt;<a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a> &lt;wchar_t&gt;, L'\0', std::wstring&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common STL wstring specification, null terminated. </p>
<dl class="section note"><dt>Note</dt><dd>This template uses little endian byte ordering to store individual characters - allowing this parameter to be user-specified here (ie: stl_wstring &lt;<code>Size</code>, <code>Value&gt;</code>) would introduce an implicit constraints or unusual mutator syntax. If this default is inadequate the <code>stl_null_basic_string</code> template should be used instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f51cdf6a41c7cc40fbe951b0da49823"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a0f51cdf6a41c7cc40fbe951b0da49823">framework::serializable::stl_wstring</a> = typedef <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a> &lt;Size, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a> &lt;wchar_t&gt;, std::wstring&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common STL wstring specification. </p>
<dl class="section note"><dt>Note</dt><dd>This template uses little endian byte ordering to store individual characters - allowing this parameter to be user-specified here (ie: stl_wstring &lt;<code>Size</code>, <code>Value&gt;</code>) would introduce an implicit constraints or unusual mutator syntax. If this default is inadequate the <code>stl_basic_string</code> template should be used instead. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a581563a786db60888b617c700dc0a8b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename Object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto framework::serializable::interface </td>
          <td>(</td>
          <td class="paramtype">Object &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; typename get_base &lt;Object, Name&gt;::type&amp;
        </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the implementation associated with <code>Name</code> in <code>Object</code>. This method should be preferred over the get/set/... free functions in <code><a class="el" href="structframework_1_1serializable_1_1serializable__specification.html" title="Serializable specification.">serializable_specification</a></code>; implementations may need to protect necessary methods outside of <code><a class="el" href="structframework_1_1serializable_1_1serializable__specification.html" title="Serializable specification.">serializable_specification</a></code> or <code><a class="el" href="structframework_1_1serializable_1_1serializable__default__specification.html" title="Default container serializer.">serializable_default_specification</a></code>. </p>

</div>
</div>
<a class="anchor" id="a780ec860d7f9b91ee52b165e80fd8195"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename Object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto framework::serializable::interface </td>
          <td>(</td>
          <td class="paramtype">Object const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; typename get_base &lt;Object, Name&gt;::type const&amp;
        </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a constant reference to the implementation associated with <code>Name</code> in <code>Object</code>. This method should be preferred over the get/set/... free functions in <code><a class="el" href="structframework_1_1serializable_1_1serializable__specification.html" title="Serializable specification.">serializable_specification</a></code>; implementations may need to protect necessary methods outside of <code><a class="el" href="structframework_1_1serializable_1_1serializable__specification.html" title="Serializable specification.">serializable_specification</a></code> or <code><a class="el" href="structframework_1_1serializable_1_1serializable__default__specification.html" title="Default container serializer.">serializable_default_specification</a></code>. </p>

</div>
</div>
<a class="anchor" id="a116938beb8e2e5e17ac3029a7b5c2e60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read fowarder. </p>
<p>Equivalent to </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceframework_1_1serializable.html#a116938beb8e2e5e17ac3029a7b5c2e60" title="Read fowarder.">serializable_specification &lt;Output&gt;::read</a>(in, out)</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a99b0af2f2f45ba69a1d6b7c7fc2dbb5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write forwarder. </p>
<p>Equivalent to </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceframework_1_1serializable.html#a99b0af2f2f45ba69a1d6b7c7fc2dbb5e" title="Write forwarder.">serializable_specification &lt;Input&gt;::write</a>(in, out)</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 24 2012 10:32:07 for framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2-20121118
</small></address>
</body>
</html>
