<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1-20130402"/>
<title>framework: framework::serializable Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1-20130402 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceframework.html">framework</a></li><li class="navelem"><a class="el" href="namespaceframework_1_1serializable.html">serializable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">framework::serializable Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Serializable namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1container__type.html">container_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializable alias wrapper.  <a href="structframework_1_1serializable_1_1alias.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1bit__field.html">bit_field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit field container.  <a href="structframework_1_1serializable_1_1bit__field.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1output__flags__frame.html">output_flags_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags frame.  <a href="classframework_1_1serializable_1_1output__flags__frame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1optional__field.html">optional_field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional field container.  <a href="structframework_1_1serializable_1_1optional__field.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1default__optional__value.html">default_optional_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional value implementation.  <a href="structframework_1_1serializable_1_1default__optional__value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1optional__value.html">optional_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional value container.  <a href="structframework_1_1serializable_1_1optional__value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1value__implementation__wrapper.html">value_implementation_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation wrapper.  <a href="structframework_1_1serializable_1_1value__implementation__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1default__value.html">default_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation.  <a href="structframework_1_1serializable_1_1default__value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1value.html">value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value container.  <a href="structframework_1_1serializable_1_1value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1inline__object.html">inline_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline object wrapper.  <a href="classframework_1_1serializable_1_1inline__object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1mutator__type.html">mutator_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1bit__value.html">bit_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1big__endian.html">big_endian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1pdp__endian.html">pdp_endian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1fixed__container.html">fixed_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1terminated__container.html">terminated_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html">serializable_implementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializable implementation.  <a href="classframework_1_1serializable_1_1serializable__implementation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1bit__stream.html">bit_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit stream.  <a href="classframework_1_1serializable_1_1bit__stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1crc__wrapper.html">crc_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC Wrapper.  <a href="classframework_1_1serializable_1_1crc__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1serializable_1_1modular__sum.html">modular_sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modular sum writer.  <a href="classframework_1_1serializable_1_1modular__sum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1comparable.html">comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparable template.  <a href="structframework_1_1serializable_1_1comparable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1serializable_1_1value__type.html">value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abb7623c8ba8e228fec475ca249f3a890"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb7623c8ba8e228fec475ca249f3a890"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#abb7623c8ba8e228fec475ca249f3a890">is_container_type</a> = typename detail::is_container_type_impl&lt; T &gt;::type</td></tr>
<tr class="separator:abb7623c8ba8e228fec475ca249f3a890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ce35a788e129f1af53a71bec787d29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91ce35a788e129f1af53a71bec787d29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a91ce35a788e129f1af53a71bec787d29">is_container_default_serializable</a> = typename detail::is_container_default_serializable_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a91ce35a788e129f1af53a71bec787d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ef460625fe9bf758b9e13c8ee987b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66ef460625fe9bf758b9e13c8ee987b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a66ef460625fe9bf758b9e13c8ee987b8">container_specification</a> = typename detail::container_specification_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a66ef460625fe9bf758b9e13c8ee987b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fc3006a12d9c2b44d6418201c09221"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94fc3006a12d9c2b44d6418201c09221"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a> = typename detail::container_children_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a94fc3006a12d9c2b44d6418201c09221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f55035b4c8eada5a8e683c6d49fdec1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f55035b4c8eada5a8e683c6d49fdec1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a4f55035b4c8eada5a8e683c6d49fdec1">is_mutator_type</a> = typename detail::is_mutator_type_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a4f55035b4c8eada5a8e683c6d49fdec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500fdba3155cccf9f4826d4f18f99a0f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a500fdba3155cccf9f4826d4f18f99a0f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a500fdba3155cccf9f4826d4f18f99a0f">mutator_child</a> = typename detail::mutator_child_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a500fdba3155cccf9f4826d4f18f99a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7441c447881d737be82d6c914a7830aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7441c447881d737be82d6c914a7830aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a> = typename detail::type_extractor_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a7441c447881d737be82d6c914a7830aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutator type extractor.  <a href="#a7441c447881d737be82d6c914a7830aa">More...</a><br/></td></tr>
<tr class="separator:a7441c447881d737be82d6c914a7830aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e314217579c86d8b437089ae79534"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac08e314217579c86d8b437089ae79534"></a>
template&lt;std::size_t Size, typename Value &gt; </td></tr>
<tr class="memitem:ac08e314217579c86d8b437089ae79534"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ac08e314217579c86d8b437089ae79534">stl_array</a> = <a class="el" href="structframework_1_1serializable_1_1fixed__container.html">fixed_container</a>&lt; Value, std::array&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;, Size &gt;&gt;</td></tr>
<tr class="memdesc:ac08e314217579c86d8b437089ae79534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL array specification. <br/></td></tr>
<tr class="separator:ac08e314217579c86d8b437089ae79534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22270fb3d6c1faa1c7061d5894b1b822"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22270fb3d6c1faa1c7061d5894b1b822"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a22270fb3d6c1faa1c7061d5894b1b822"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a22270fb3d6c1faa1c7061d5894b1b822">stl_deque</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::deque&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a22270fb3d6c1faa1c7061d5894b1b822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL deque specification. <br/></td></tr>
<tr class="separator:a22270fb3d6c1faa1c7061d5894b1b822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7986aaadc8c33347fd1db95c3756116"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7986aaadc8c33347fd1db95c3756116"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:aa7986aaadc8c33347fd1db95c3756116"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#aa7986aaadc8c33347fd1db95c3756116">stl_forward_list</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::forward_list&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;&gt;&gt;</td></tr>
<tr class="memdesc:aa7986aaadc8c33347fd1db95c3756116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL forward list specification. <br/></td></tr>
<tr class="separator:aa7986aaadc8c33347fd1db95c3756116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab331c847758603e95e266f0f1edc25"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ab331c847758603e95e266f0f1edc25"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a4ab331c847758603e95e266f0f1edc25"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a4ab331c847758603e95e266f0f1edc25">stl_list</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::list&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a4ab331c847758603e95e266f0f1edc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL list specification. <br/></td></tr>
<tr class="separator:a4ab331c847758603e95e266f0f1edc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ba2bd86210bf24a24d1baf45c40a70"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad4ba2bd86210bf24a24d1baf45c40a70"></a>
template&lt;typename Size , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad4ba2bd86210bf24a24d1baf45c40a70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ad4ba2bd86210bf24a24d1baf45c40a70">stl_map</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a9433d3faa2fff20c0be0de80dca68f22">stl_pair</a>&lt; T1, T2 &gt;, std::map&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T1 &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T2 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ad4ba2bd86210bf24a24d1baf45c40a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL map specification. <br/></td></tr>
<tr class="separator:ad4ba2bd86210bf24a24d1baf45c40a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725b85c833cb4611bdd9e028f6782999"><td class="memTemplParams" colspan="2"><a class="anchor" id="a725b85c833cb4611bdd9e028f6782999"></a>
template&lt;typename Size , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a725b85c833cb4611bdd9e028f6782999"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a725b85c833cb4611bdd9e028f6782999">stl_multimap</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a9433d3faa2fff20c0be0de80dca68f22">stl_pair</a>&lt; T1, T2 &gt;, std::multimap&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T1 &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T2 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a725b85c833cb4611bdd9e028f6782999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL multimap specification. <br/></td></tr>
<tr class="separator:a725b85c833cb4611bdd9e028f6782999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9433d3faa2fff20c0be0de80dca68f22"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9433d3faa2fff20c0be0de80dca68f22"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9433d3faa2fff20c0be0de80dca68f22"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a9433d3faa2fff20c0be0de80dca68f22">stl_pair</a> = <a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a>&lt; <a class="el" href="structframework_1_1pack__container.html">pack_container</a>&lt; T1, T2 &gt;, std::pair&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T1 &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T2 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a9433d3faa2fff20c0be0de80dca68f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL pair specification. <br/></td></tr>
<tr class="separator:a9433d3faa2fff20c0be0de80dca68f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae18ae2570058468a7e57283ffc20da"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ae18ae2570058468a7e57283ffc20da"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a2ae18ae2570058468a7e57283ffc20da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a2ae18ae2570058468a7e57283ffc20da">stl_set</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::set&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a2ae18ae2570058468a7e57283ffc20da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL set specification. <br/></td></tr>
<tr class="separator:a2ae18ae2570058468a7e57283ffc20da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af117c0b73218087e6248789ea2161e1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="af117c0b73218087e6248789ea2161e1d"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:af117c0b73218087e6248789ea2161e1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#af117c0b73218087e6248789ea2161e1d">stl_multiset</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::multiset&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;&gt;&gt;</td></tr>
<tr class="memdesc:af117c0b73218087e6248789ea2161e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL multiset specification. <br/></td></tr>
<tr class="separator:af117c0b73218087e6248789ea2161e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d395d731b8146459ae379c56637ba9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28d395d731b8146459ae379c56637ba9"></a>
template&lt;typename Size &gt; </td></tr>
<tr class="memitem:a28d395d731b8146459ae379c56637ba9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a28d395d731b8146459ae379c56637ba9">stl_string</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, char, std::string, true &gt;</td></tr>
<tr class="memdesc:a28d395d731b8146459ae379c56637ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL string specification. <br/></td></tr>
<tr class="separator:a28d395d731b8146459ae379c56637ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393b82ceaf2c0005da89d6f47fd34380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a393b82ceaf2c0005da89d6f47fd34380"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a393b82ceaf2c0005da89d6f47fd34380">stl_null_string</a> = <a class="el" href="structframework_1_1serializable_1_1terminated__container.html">terminated_container</a>&lt; char, '\0', std::string &gt;</td></tr>
<tr class="memdesc:a393b82ceaf2c0005da89d6f47fd34380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL string specification, null terminated. <br/></td></tr>
<tr class="separator:a393b82ceaf2c0005da89d6f47fd34380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f51cdf6a41c7cc40fbe951b0da49823"><td class="memTemplParams" colspan="2">template&lt;typename Size &gt; </td></tr>
<tr class="memitem:a0f51cdf6a41c7cc40fbe951b0da49823"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a0f51cdf6a41c7cc40fbe951b0da49823">stl_wstring</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a>&lt; wchar_t &gt;, std::wstring &gt;</td></tr>
<tr class="memdesc:a0f51cdf6a41c7cc40fbe951b0da49823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL wstring specification.  <a href="#a0f51cdf6a41c7cc40fbe951b0da49823">More...</a><br/></td></tr>
<tr class="separator:a0f51cdf6a41c7cc40fbe951b0da49823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bcbbe8ff9188999b4be65b9bd06f64"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a60bcbbe8ff9188999b4be65b9bd06f64">stl_null_wstring</a> = <a class="el" href="structframework_1_1serializable_1_1terminated__container.html">terminated_container</a>&lt; <a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a>&lt; wchar_t &gt;, L'\0', std::wstring &gt;</td></tr>
<tr class="memdesc:a60bcbbe8ff9188999b4be65b9bd06f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL wstring specification, null terminated.  <a href="#a60bcbbe8ff9188999b4be65b9bd06f64">More...</a><br/></td></tr>
<tr class="separator:a60bcbbe8ff9188999b4be65b9bd06f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339cfdbe2f4e43c42d95d548bc1a575d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a339cfdbe2f4e43c42d95d548bc1a575d"></a>
template&lt;typename Size , typename CharT , typename Traits  = std::char_traits &lt;type_extractor &lt;CharT&gt;&gt;, typename Allocator  = std::allocator &lt;type_extractor &lt;CharT&gt;&gt;&gt; </td></tr>
<tr class="memitem:a339cfdbe2f4e43c42d95d548bc1a575d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a339cfdbe2f4e43c42d95d548bc1a575d">stl_basic_string</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; CharT &gt;, std::basic_string&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; CharT &gt;, Traits, Allocator &gt;&gt;</td></tr>
<tr class="memdesc:a339cfdbe2f4e43c42d95d548bc1a575d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL basic string specification. <br/></td></tr>
<tr class="separator:a339cfdbe2f4e43c42d95d548bc1a575d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d73086ebd67aaf7e48b8505e083cbf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7d73086ebd67aaf7e48b8505e083cbf"></a>
template&lt;typename CharT , typename Traits  = std::char_traits &lt;type_extractor &lt;CharT&gt;&gt;, typename Allocator  = std::allocator &lt;type_extractor &lt;CharT&gt;&gt;&gt; </td></tr>
<tr class="memitem:ae7d73086ebd67aaf7e48b8505e083cbf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ae7d73086ebd67aaf7e48b8505e083cbf">stl_null_basic_string</a> = <a class="el" href="structframework_1_1serializable_1_1terminated__container.html">terminated_container</a>&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; CharT &gt;, static_cast&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; CharT &gt;&gt;(0), std::basic_string&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; CharT &gt;, Traits, Allocator &gt;&gt;</td></tr>
<tr class="memdesc:ae7d73086ebd67aaf7e48b8505e083cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL basic string specification, null terminated. <br/></td></tr>
<tr class="separator:ae7d73086ebd67aaf7e48b8505e083cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b3ecf3edce21459be1ef6d41084fca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86b3ecf3edce21459be1ef6d41084fca"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a86b3ecf3edce21459be1ef6d41084fca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a86b3ecf3edce21459be1ef6d41084fca">stl_tuple</a> = <a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a>&lt; <a class="el" href="structframework_1_1pack__container.html">pack_container</a>&lt; Types...&gt;, std::tuple&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Types &gt;...&gt;&gt;</td></tr>
<tr class="memdesc:a86b3ecf3edce21459be1ef6d41084fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL tuple specification. <br/></td></tr>
<tr class="separator:a86b3ecf3edce21459be1ef6d41084fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84aabbe23591096ddb2cff903243b36"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa84aabbe23591096ddb2cff903243b36"></a>
template&lt;typename Size , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa84aabbe23591096ddb2cff903243b36"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#aa84aabbe23591096ddb2cff903243b36">stl_unordered_map</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a9433d3faa2fff20c0be0de80dca68f22">stl_pair</a>&lt; T1, T2 &gt;, std::unordered_map&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T1 &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T2 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:aa84aabbe23591096ddb2cff903243b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL map specification. <br/></td></tr>
<tr class="separator:aa84aabbe23591096ddb2cff903243b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad899fa6c0b75b99408c78dc9a90050d0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad899fa6c0b75b99408c78dc9a90050d0"></a>
template&lt;typename Size , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad899fa6c0b75b99408c78dc9a90050d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ad899fa6c0b75b99408c78dc9a90050d0">stl_unordered_multimap</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, <a class="el" href="namespaceframework_1_1serializable.html#a9433d3faa2fff20c0be0de80dca68f22">stl_pair</a>&lt; T1, T2 &gt;, std::unordered_multimap&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T1 &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; T2 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ad899fa6c0b75b99408c78dc9a90050d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL multimap specification. <br/></td></tr>
<tr class="separator:ad899fa6c0b75b99408c78dc9a90050d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddf4c558e0219e0262efd47b8c6ad5a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ddf4c558e0219e0262efd47b8c6ad5a"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a2ddf4c558e0219e0262efd47b8c6ad5a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a2ddf4c558e0219e0262efd47b8c6ad5a">stl_unordered_set</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::unordered_set&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a2ddf4c558e0219e0262efd47b8c6ad5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL set specification. <br/></td></tr>
<tr class="separator:a2ddf4c558e0219e0262efd47b8c6ad5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c8d522e2d25f857aee7a2aa3b67993"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11c8d522e2d25f857aee7a2aa3b67993"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a11c8d522e2d25f857aee7a2aa3b67993"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a11c8d522e2d25f857aee7a2aa3b67993">stl_unordered_multiset</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::unordered_multiset&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a11c8d522e2d25f857aee7a2aa3b67993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL multiset specification. <br/></td></tr>
<tr class="separator:a11c8d522e2d25f857aee7a2aa3b67993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b30d580450ad68ab41eb22711c65e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a84b30d580450ad68ab41eb22711c65e0"></a>
template&lt;typename Size , typename Value &gt; </td></tr>
<tr class="memitem:a84b30d580450ad68ab41eb22711c65e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a84b30d580450ad68ab41eb22711c65e0">stl_vector</a> = <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, std::vector&lt; <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;&gt;, true &gt;</td></tr>
<tr class="memdesc:a84b30d580450ad68ab41eb22711c65e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common STL vector specification. <br/></td></tr>
<tr class="separator:a84b30d580450ad68ab41eb22711c65e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff925ed4d0a4068e305966aa02a7421"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ff925ed4d0a4068e305966aa02a7421"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a9ff925ed4d0a4068e305966aa02a7421">is_object_type</a> = typename detail::is_object_type_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a9ff925ed4d0a4068e305966aa02a7421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b875688b6f74cafb34078cbf20a101f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b875688b6f74cafb34078cbf20a101f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a4b875688b6f74cafb34078cbf20a101f">is_object_default_serializable</a> = typename detail::is_object_default_serializable_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a4b875688b6f74cafb34078cbf20a101f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713b06731ae75399cacf92e1e71d9f0e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Name &gt; </td></tr>
<tr class="memitem:a713b06731ae75399cacf92e1e71d9f0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a713b06731ae75399cacf92e1e71d9f0e">object_base</a> = typename detail::object_base_impl&lt; T, Name &gt;::type</td></tr>
<tr class="separator:a713b06731ae75399cacf92e1e71d9f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e25409b4ac5207bede8f725e417452"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40e25409b4ac5207bede8f725e417452"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a40e25409b4ac5207bede8f725e417452">object_names</a> = typename detail::object_names_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a40e25409b4ac5207bede8f725e417452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4524878d84fde38e8dbf549177a7c6a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4524878d84fde38e8dbf549177a7c6a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a4524878d84fde38e8dbf549177a7c6a3">object_specification</a> = typename detail::object_specification_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a4524878d84fde38e8dbf549177a7c6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf4ac1103ad890ccd680d232ae3acdc"><td class="memTemplParams" colspan="2">template&lt;typename Pack , template&lt; typename &gt; class Path&gt; </td></tr>
<tr class="memitem:a1cf4ac1103ad890ccd680d232ae3acdc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a> = typename detail::extract_values_impl&lt; Pack, Path &gt;::type</td></tr>
<tr class="memdesc:a1cf4ac1103ad890ccd680d232ae3acdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts value types.  <a href="#a1cf4ac1103ad890ccd680d232ae3acdc">More...</a><br/></td></tr>
<tr class="separator:a1cf4ac1103ad890ccd680d232ae3acdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b717d04f56cc58bb9f27ceb31e273f0"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Specification&gt; </td></tr>
<tr class="memitem:a7b717d04f56cc58bb9f27ceb31e273f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a7b717d04f56cc58bb9f27ceb31e273f0">serializable</a> = <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html">serializable_implementation</a>&lt; Derived, <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a66ef460625fe9bf758b9e13c8ee987b8">container_specification</a> &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a> &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a> &gt;&gt;</td></tr>
<tr class="memdesc:a7b717d04f56cc58bb9f27ceb31e273f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation alias.  <a href="#a7b717d04f56cc58bb9f27ceb31e273f0">More...</a><br/></td></tr>
<tr class="separator:a7b717d04f56cc58bb9f27ceb31e273f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7615226856136a967541b6d9e06587ea"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Specification&gt; </td></tr>
<tr class="memitem:a7615226856136a967541b6d9e06587ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a7615226856136a967541b6d9e06587ea">custom_serializable</a> = <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html">serializable_implementation</a>&lt; Derived, <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a66ef460625fe9bf758b9e13c8ee987b8">container_specification</a> &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a> &gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a>&lt; <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a>&lt; Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a> &gt;, false &gt;</td></tr>
<tr class="memdesc:a7615226856136a967541b6d9e06587ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation alias.  <a href="#a7615226856136a967541b6d9e06587ea">More...</a><br/></td></tr>
<tr class="separator:a7615226856136a967541b6d9e06587ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb1658f6947535ce4c60f585e186bd2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacb1658f6947535ce4c60f585e186bd2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#aacb1658f6947535ce4c60f585e186bd2">is_value_type</a> = typename detail::is_value_type_impl&lt; T &gt;::type</td></tr>
<tr class="separator:aacb1658f6947535ce4c60f585e186bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ae4dff8c1b786094991d385d805e4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22ae4dff8c1b786094991d385d805e4f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a22ae4dff8c1b786094991d385d805e4f">is_value_default_serializable</a> = typename detail::is_value_type_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a22ae4dff8c1b786094991d385d805e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160c5b90af1270f9021ceaaa24e3b494"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a160c5b90af1270f9021ceaaa24e3b494"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a160c5b90af1270f9021ceaaa24e3b494">value_name</a> = typename detail::value_name_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a160c5b90af1270f9021ceaaa24e3b494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537b4c9c082ffa1a9836f3fd38ed25fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a537b4c9c082ffa1a9836f3fd38ed25fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a537b4c9c082ffa1a9836f3fd38ed25fa">value_specification</a> = typename detail::value_specification_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a537b4c9c082ffa1a9836f3fd38ed25fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0846f79acb10835a92abacd11ea6bdd5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Derived &gt; </td></tr>
<tr class="memitem:a0846f79acb10835a92abacd11ea6bdd5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a0846f79acb10835a92abacd11ea6bdd5">value_implementation</a> = typename detail::value_implementation_impl&lt; T, Derived &gt;::type</td></tr>
<tr class="separator:a0846f79acb10835a92abacd11ea6bdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a29bb2b422a55301e439c8c42808b7052"><td class="memTemplParams" colspan="2"><a class="anchor" id="a29bb2b422a55301e439c8c42808b7052"></a>
template&lt;typename Input , typename T &gt; </td></tr>
<tr class="memitem:a29bb2b422a55301e439c8c42808b7052"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a>, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a29bb2b422a55301e439c8c42808b7052">read_dispatch</a> (T *, Input &amp;in, T &amp;out)</td></tr>
<tr class="memdesc:a29bb2b422a55301e439c8c42808b7052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic read overload. <br/></td></tr>
<tr class="separator:a29bb2b422a55301e439c8c42808b7052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e7794709185fa002142af3edeb98b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8e7794709185fa002142af3edeb98b4"></a>
template&lt;typename Output , typename T &gt; </td></tr>
<tr class="memitem:ae8e7794709185fa002142af3edeb98b4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a>, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ae8e7794709185fa002142af3edeb98b4">write_dispatch</a> (T *, T in, Output &amp;out)</td></tr>
<tr class="memdesc:ae8e7794709185fa002142af3edeb98b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic write overload. <br/></td></tr>
<tr class="separator:ae8e7794709185fa002142af3edeb98b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3383ecea9cc1f5f7e4243b6fcbb60c0"><td class="memTemplParams" colspan="2">template&lt;typename Specification , typename... Args&gt; </td></tr>
<tr class="memitem:ac3383ecea9cc1f5f7e4243b6fcbb60c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ac3383ecea9cc1f5f7e4243b6fcbb60c0">dispatch_read</a> (Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a29bb2b422a55301e439c8c42808b7052">read_dispatch</a>(static_cast&lt; Specification * &gt;(nullptr), std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:ac3383ecea9cc1f5f7e4243b6fcbb60c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatched read forwarder.  <a href="#ac3383ecea9cc1f5f7e4243b6fcbb60c0">More...</a><br/></td></tr>
<tr class="separator:ac3383ecea9cc1f5f7e4243b6fcbb60c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee613a7c1faaae8cf8731b5441c4be4"><td class="memTemplParams" colspan="2">template&lt;typename Specification , typename... Args&gt; </td></tr>
<tr class="memitem:a4ee613a7c1faaae8cf8731b5441c4be4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a4ee613a7c1faaae8cf8731b5441c4be4">dispatch_write</a> (Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#ae8e7794709185fa002142af3edeb98b4">write_dispatch</a>(static_cast&lt; Specification * &gt;(nullptr), std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a4ee613a7c1faaae8cf8731b5441c4be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatched write forwarder.  <a href="#a4ee613a7c1faaae8cf8731b5441c4be4">More...</a><br/></td></tr>
<tr class="separator:a4ee613a7c1faaae8cf8731b5441c4be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf40b80e08e58e843ac0fb050c468cab"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Stream &gt; </td></tr>
<tr class="memitem:acf40b80e08e58e843ac0fb050c468cab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#acf40b80e08e58e843ac0fb050c468cab">stream_read</a> (Stream &amp;&amp;stream, void *s)</td></tr>
<tr class="memdesc:acf40b80e08e58e843ac0fb050c468cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream read forwarder.  <a href="#acf40b80e08e58e843ac0fb050c468cab">More...</a><br/></td></tr>
<tr class="separator:acf40b80e08e58e843ac0fb050c468cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e49254100130f450167d1b5c70aed7"><td class="memTemplParams" colspan="2">template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:aa9e49254100130f450167d1b5c70aed7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#aa9e49254100130f450167d1b5c70aed7">stream_read</a> (Stream &amp;&amp;stream, void *s, std::size_t n)</td></tr>
<tr class="memdesc:aa9e49254100130f450167d1b5c70aed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream read forwarder.  <a href="#aa9e49254100130f450167d1b5c70aed7">More...</a><br/></td></tr>
<tr class="separator:aa9e49254100130f450167d1b5c70aed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2def8034de5c04de173ee8da33a0da09"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Stream &gt; </td></tr>
<tr class="memitem:a2def8034de5c04de173ee8da33a0da09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a2def8034de5c04de173ee8da33a0da09">stream_write</a> (Stream &amp;&amp;stream, void const *s)</td></tr>
<tr class="memdesc:a2def8034de5c04de173ee8da33a0da09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream write forwarder.  <a href="#a2def8034de5c04de173ee8da33a0da09">More...</a><br/></td></tr>
<tr class="separator:a2def8034de5c04de173ee8da33a0da09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff339264ca138bd9d60413bf3cf201a"><td class="memTemplParams" colspan="2">template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:a1ff339264ca138bd9d60413bf3cf201a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a1ff339264ca138bd9d60413bf3cf201a">stream_write</a> (Stream &amp;&amp;stream, void const *s, std::size_t n)</td></tr>
<tr class="memdesc:a1ff339264ca138bd9d60413bf3cf201a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream write forwarder.  <a href="#a1ff339264ca138bd9d60413bf3cf201a">More...</a><br/></td></tr>
<tr class="separator:a1ff339264ca138bd9d60413bf3cf201a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093822d3d91e86e60cc948935e383fec"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a093822d3d91e86e60cc948935e383fec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a093822d3d91e86e60cc948935e383fec">read</a> (Input &amp;&amp;in, Output &amp;&amp;out) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#ac3383ecea9cc1f5f7e4243b6fcbb60c0">dispatch_read</a>&lt; reference_base&lt; Output &gt;&gt;(std::forward&lt; Input &gt;(in), std::forward&lt; Output &gt;(out)))</td></tr>
<tr class="memdesc:a093822d3d91e86e60cc948935e383fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read forwarder.  <a href="#a093822d3d91e86e60cc948935e383fec">More...</a><br/></td></tr>
<tr class="separator:a093822d3d91e86e60cc948935e383fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c411f3a0194a69a374492044f2fcea0"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a8c411f3a0194a69a374492044f2fcea0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a8c411f3a0194a69a374492044f2fcea0">write</a> (Input &amp;&amp;in, Output &amp;&amp;out) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a4ee613a7c1faaae8cf8731b5441c4be4">dispatch_write</a>&lt; reference_base&lt; Input &gt;&gt;(std::forward&lt; Input &gt;(in), std::forward&lt; Output &gt;(out)))</td></tr>
<tr class="memdesc:a8c411f3a0194a69a374492044f2fcea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write forwarder.  <a href="#a8c411f3a0194a69a374492044f2fcea0">More...</a><br/></td></tr>
<tr class="separator:a8c411f3a0194a69a374492044f2fcea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbd87663a2ce7a6f2caf71b882d07bd"><td class="memTemplParams" colspan="2">template&lt;typename Specification , typename Children , typename... Args&gt; </td></tr>
<tr class="memitem:a1fbd87663a2ce7a6f2caf71b882d07bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a1fbd87663a2ce7a6f2caf71b882d07bd">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1container__type.html">container_type</a>&lt; Specification, Children, true &gt; *, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1fbd87663a2ce7a6f2caf71b882d07bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default read overload.  <a href="#a1fbd87663a2ce7a6f2caf71b882d07bd">More...</a><br/></td></tr>
<tr class="separator:a1fbd87663a2ce7a6f2caf71b882d07bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c628660258f76477013850124a1e0c6"><td class="memTemplParams" colspan="2">template&lt;typename Specification , typename Children , typename... Args&gt; </td></tr>
<tr class="memitem:a1c628660258f76477013850124a1e0c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a1c628660258f76477013850124a1e0c6">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1container__type.html">container_type</a>&lt; Specification, Children, true &gt; *, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1c628660258f76477013850124a1e0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default write overload.  <a href="#a1c628660258f76477013850124a1e0c6">More...</a><br/></td></tr>
<tr class="separator:a1c628660258f76477013850124a1e0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad384421d3632342e453a7a2eec0c2e39"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output , typename Block , typename... Specification&gt; </td></tr>
<tr class="memitem:ad384421d3632342e453a7a2eec0c2e39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ad384421d3632342e453a7a2eec0c2e39">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1bit__field.html">bit_field</a>&lt; Block, Specification...&gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:ad384421d3632342e453a7a2eec0c2e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#ad384421d3632342e453a7a2eec0c2e39">More...</a><br/></td></tr>
<tr class="separator:ad384421d3632342e453a7a2eec0c2e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cea0667671aa34b7e5e87ee1a38617"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output , typename Block , typename... Specification&gt; </td></tr>
<tr class="memitem:a70cea0667671aa34b7e5e87ee1a38617"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a70cea0667671aa34b7e5e87ee1a38617">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1bit__field.html">bit_field</a>&lt; Block, Specification...&gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a70cea0667671aa34b7e5e87ee1a38617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#a70cea0667671aa34b7e5e87ee1a38617">More...</a><br/></td></tr>
<tr class="separator:a70cea0667671aa34b7e5e87ee1a38617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc1129b592acb769ea50eb212a3d524"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Specification, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:acbc1129b592acb769ea50eb212a3d524"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#acbc1129b592acb769ea50eb212a3d524">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1optional__field.html">optional_field</a>&lt; Type, Specification...&gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:acbc1129b592acb769ea50eb212a3d524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#acbc1129b592acb769ea50eb212a3d524">More...</a><br/></td></tr>
<tr class="separator:acbc1129b592acb769ea50eb212a3d524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3585a25c97ba8c548f4816dd896e8e5"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Specification, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ae3585a25c97ba8c548f4816dd896e8e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ae3585a25c97ba8c548f4816dd896e8e5">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1optional__field.html">optional_field</a>&lt; Type, Specification...&gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:ae3585a25c97ba8c548f4816dd896e8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#ae3585a25c97ba8c548f4816dd896e8e5">More...</a><br/></td></tr>
<tr class="separator:ae3585a25c97ba8c548f4816dd896e8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583d230ea0e1e1a0b0646b0bffb3b6f8"><td class="memTemplParams" colspan="2">template&lt;int64_t Flag, typename Name , typename Specification , template&lt; typename &gt; class Implementation, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a583d230ea0e1e1a0b0646b0bffb3b6f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a583d230ea0e1e1a0b0646b0bffb3b6f8">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1optional__value.html">optional_value</a>&lt; Flag, Name, Specification, Implementation &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a583d230ea0e1e1a0b0646b0bffb3b6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#a583d230ea0e1e1a0b0646b0bffb3b6f8">More...</a><br/></td></tr>
<tr class="separator:a583d230ea0e1e1a0b0646b0bffb3b6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eabc02808d7139ddd4d218160ebf7b"><td class="memTemplParams" colspan="2">template&lt;int64_t Flag, typename Name , typename Specification , template&lt; typename &gt; class Implementation, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a79eabc02808d7139ddd4d218160ebf7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a79eabc02808d7139ddd4d218160ebf7b">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1optional__value.html">optional_value</a>&lt; Flag, Name, Specification, Implementation &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a79eabc02808d7139ddd4d218160ebf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#a79eabc02808d7139ddd4d218160ebf7b">More...</a><br/></td></tr>
<tr class="separator:a79eabc02808d7139ddd4d218160ebf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44e43094d0b96fe5d1bb118af59e094"><td class="memTemplParams" colspan="2">template&lt;int64_t Flag, typename Name , typename Specification , template&lt; typename &gt; class Implementation, typename Input , typename Type &gt; </td></tr>
<tr class="memitem:ac44e43094d0b96fe5d1bb118af59e094"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ac44e43094d0b96fe5d1bb118af59e094">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1optional__value.html">optional_value</a>&lt; Flag, Name, Specification, Implementation &gt; *, Input const &amp;in, <a class="el" href="classframework_1_1serializable_1_1output__flags__frame.html">output_flags_frame</a>&lt; Type &gt; &amp;out)</td></tr>
<tr class="memdesc:ac44e43094d0b96fe5d1bb118af59e094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#ac44e43094d0b96fe5d1bb118af59e094">More...</a><br/></td></tr>
<tr class="separator:ac44e43094d0b96fe5d1bb118af59e094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69252a82c239399bc1d38530e6c621a1"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Value , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a69252a82c239399bc1d38530e6c621a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a69252a82c239399bc1d38530e6c621a1">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1bit__value.html">bit_value</a>&lt; N, Value &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a69252a82c239399bc1d38530e6c621a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#a69252a82c239399bc1d38530e6c621a1">More...</a><br/></td></tr>
<tr class="separator:a69252a82c239399bc1d38530e6c621a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e897d843f8a319b443b8fdc92dec94"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Value , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ac8e897d843f8a319b443b8fdc92dec94"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ac8e897d843f8a319b443b8fdc92dec94">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1bit__value.html">bit_value</a>&lt; N, Value &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:ac8e897d843f8a319b443b8fdc92dec94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#ac8e897d843f8a319b443b8fdc92dec94">More...</a><br/></td></tr>
<tr class="separator:ac8e897d843f8a319b443b8fdc92dec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f1483c270b49df99f76543e3130a29"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ad5f1483c270b49df99f76543e3130a29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ad5f1483c270b49df99f76543e3130a29">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a>&lt; T &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:ad5f1483c270b49df99f76543e3130a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#ad5f1483c270b49df99f76543e3130a29">More...</a><br/></td></tr>
<tr class="separator:ad5f1483c270b49df99f76543e3130a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb11c7a99b282a94927fc94e61a7179"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a2eb11c7a99b282a94927fc94e61a7179"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a2eb11c7a99b282a94927fc94e61a7179">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a>&lt; T &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a2eb11c7a99b282a94927fc94e61a7179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#a2eb11c7a99b282a94927fc94e61a7179">More...</a><br/></td></tr>
<tr class="separator:a2eb11c7a99b282a94927fc94e61a7179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984713cd5500fda66fe4634bfa16b526"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a984713cd5500fda66fe4634bfa16b526"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a984713cd5500fda66fe4634bfa16b526">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1big__endian.html">big_endian</a>&lt; T &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a984713cd5500fda66fe4634bfa16b526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#a984713cd5500fda66fe4634bfa16b526">More...</a><br/></td></tr>
<tr class="separator:a984713cd5500fda66fe4634bfa16b526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70ffbf4b31750786e8a82ea76e0d9a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ad70ffbf4b31750786e8a82ea76e0d9a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ad70ffbf4b31750786e8a82ea76e0d9a9">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1big__endian.html">big_endian</a>&lt; T &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:ad70ffbf4b31750786e8a82ea76e0d9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#ad70ffbf4b31750786e8a82ea76e0d9a9">More...</a><br/></td></tr>
<tr class="separator:ad70ffbf4b31750786e8a82ea76e0d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ce72aea2369fb39049f532023f7b38"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a47ce72aea2369fb39049f532023f7b38"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a47ce72aea2369fb39049f532023f7b38">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1pdp__endian.html">pdp_endian</a>&lt; T &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a47ce72aea2369fb39049f532023f7b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#a47ce72aea2369fb39049f532023f7b38">More...</a><br/></td></tr>
<tr class="separator:a47ce72aea2369fb39049f532023f7b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348cc209ccb5a2958f690e9489b255ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a348cc209ccb5a2958f690e9489b255ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a348cc209ccb5a2958f690e9489b255ba">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1pdp__endian.html">pdp_endian</a>&lt; T &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a348cc209ccb5a2958f690e9489b255ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#a348cc209ccb5a2958f690e9489b255ba">More...</a><br/></td></tr>
<tr class="separator:a348cc209ccb5a2958f690e9489b255ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0febf21d62b3c2612c6a0697cf5ef0"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename Container , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:aab0febf21d62b3c2612c6a0697cf5ef0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#aab0febf21d62b3c2612c6a0697cf5ef0">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1fixed__container.html">fixed_container</a>&lt; Value, Container &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:aab0febf21d62b3c2612c6a0697cf5ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#aab0febf21d62b3c2612c6a0697cf5ef0">More...</a><br/></td></tr>
<tr class="separator:aab0febf21d62b3c2612c6a0697cf5ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab51978b9416c9abef1e4112ed0f4f1"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename Container , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:abab51978b9416c9abef1e4112ed0f4f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#abab51978b9416c9abef1e4112ed0f4f1">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1fixed__container.html">fixed_container</a>&lt; Value, Container &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:abab51978b9416c9abef1e4112ed0f4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#abab51978b9416c9abef1e4112ed0f4f1">More...</a><br/></td></tr>
<tr class="separator:abab51978b9416c9abef1e4112ed0f4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362430520160e5538c743c2ec765c6f4"><td class="memTemplParams" colspan="2">template&lt;typename Value , type_extractor&lt; Value &gt; Terminator, typename Container , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a362430520160e5538c743c2ec765c6f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a362430520160e5538c743c2ec765c6f4">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1terminated__container.html">terminated_container</a>&lt; Value, Terminator, Container &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a362430520160e5538c743c2ec765c6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#a362430520160e5538c743c2ec765c6f4">More...</a><br/></td></tr>
<tr class="separator:a362430520160e5538c743c2ec765c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcaa1d92b698abf080d6972392547c5"><td class="memTemplParams" colspan="2">template&lt;typename Value , type_extractor&lt; Value &gt; Terminator, typename Container , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a4bcaa1d92b698abf080d6972392547c5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a4bcaa1d92b698abf080d6972392547c5">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1terminated__container.html">terminated_container</a>&lt; Value, Terminator, Container &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a4bcaa1d92b698abf080d6972392547c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#a4bcaa1d92b698abf080d6972392547c5">More...</a><br/></td></tr>
<tr class="separator:a4bcaa1d92b698abf080d6972392547c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e2278fc3735281805887007034b7df"><td class="memTemplParams" colspan="2">template&lt;typename... Parameters, typename Container , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a39e2278fc3735281805887007034b7df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a39e2278fc3735281805887007034b7df">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a>&lt; <a class="el" href="structframework_1_1pack__container.html">pack_container</a>&lt; Parameters...&gt;, Container &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a39e2278fc3735281805887007034b7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#a39e2278fc3735281805887007034b7df">More...</a><br/></td></tr>
<tr class="separator:a39e2278fc3735281805887007034b7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f989b96f85125f40c319c9aa978d7f"><td class="memTemplParams" colspan="2">template&lt;typename... Parameters, typename Container , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ae3f989b96f85125f40c319c9aa978d7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ae3f989b96f85125f40c319c9aa978d7f">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1tuple__container.html">tuple_container</a>&lt; <a class="el" href="structframework_1_1pack__container.html">pack_container</a>&lt; Parameters...&gt;, Container &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:ae3f989b96f85125f40c319c9aa978d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#ae3f989b96f85125f40c319c9aa978d7f">More...</a><br/></td></tr>
<tr class="separator:ae3f989b96f85125f40c319c9aa978d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018ab772f5ac35da248579c52180b3f4"><td class="memTemplParams" colspan="2">template&lt;typename Size , typename Value , typename Container , bool Continuous, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a018ab772f5ac35da248579c52180b3f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a018ab772f5ac35da248579c52180b3f4">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, Container, Continuous &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a018ab772f5ac35da248579c52180b3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read overload.  <a href="#a018ab772f5ac35da248579c52180b3f4">More...</a><br/></td></tr>
<tr class="separator:a018ab772f5ac35da248579c52180b3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa84fe9ee6e886610c0d4d79d2473bd"><td class="memTemplParams" colspan="2">template&lt;typename Size , typename Value , typename Container , bool Continuous, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a3fa84fe9ee6e886610c0d4d79d2473bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a3fa84fe9ee6e886610c0d4d79d2473bd">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, Container, Continuous &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a3fa84fe9ee6e886610c0d4d79d2473bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write overload.  <a href="#a3fa84fe9ee6e886610c0d4d79d2473bd">More...</a><br/></td></tr>
<tr class="separator:a3fa84fe9ee6e886610c0d4d79d2473bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2430a4654eb64e100857486ab1c02896"><td class="memTemplParams" colspan="2">template&lt;typename Size , typename Value , typename Container , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a2430a4654eb64e100857486ab1c02896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> <br class="typebreak"/>
std::enable_if&lt; std::is_same<br class="typebreak"/>
&lt; Value, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;<br class="typebreak"/>
 &gt;::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a> &amp;&amp;std::is_scalar<br class="typebreak"/>
&lt; Value &gt;::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a>, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a2430a4654eb64e100857486ab1c02896">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, Container, true &gt; *, Input &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a2430a4654eb64e100857486ab1c02896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block read overload.  <a href="#a2430a4654eb64e100857486ab1c02896">More...</a><br/></td></tr>
<tr class="separator:a2430a4654eb64e100857486ab1c02896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53424ccfbee253f0f0c6ecdc9b553070"><td class="memTemplParams" colspan="2">template&lt;typename Size , typename Value , typename Container , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a53424ccfbee253f0f0c6ecdc9b553070"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> <br class="typebreak"/>
std::enable_if&lt; std::is_same<br class="typebreak"/>
&lt; Value, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a>&lt; Value &gt;<br class="typebreak"/>
 &gt;::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a> &amp;&amp;std::is_scalar<br class="typebreak"/>
&lt; Value &gt;::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a>, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a53424ccfbee253f0f0c6ecdc9b553070">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a>&lt; Size, Value, Container, true &gt; *, Input const &amp;in, Output &amp;out)</td></tr>
<tr class="memdesc:a53424ccfbee253f0f0c6ecdc9b553070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block write overload.  <a href="#a53424ccfbee253f0f0c6ecdc9b553070">More...</a><br/></td></tr>
<tr class="separator:a53424ccfbee253f0f0c6ecdc9b553070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b622ac2f604fe40df069a7de53ba5fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b622ac2f604fe40df069a7de53ba5fb"></a>
template&lt;typename Name , typename Object , typename... Args&gt; </td></tr>
<tr class="memitem:a4b622ac2f604fe40df069a7de53ba5fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a4b622ac2f604fe40df069a7de53ba5fb">get</a> (Object const &amp;t, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a8c4a7dcd17a9cadde83d7ad91b7478ee">interface</a>&lt; Name &gt;(t).get(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a4b622ac2f604fe40df069a7de53ba5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get. <br/></td></tr>
<tr class="separator:a4b622ac2f604fe40df069a7de53ba5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07266bac81516113c418b4cb4994cdd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab07266bac81516113c418b4cb4994cdd"></a>
template&lt;typename Name , typename Object , typename... Args&gt; </td></tr>
<tr class="memitem:ab07266bac81516113c418b4cb4994cdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#ab07266bac81516113c418b4cb4994cdd">set</a> (Object &amp;t, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a8c4a7dcd17a9cadde83d7ad91b7478ee">interface</a>&lt; Name &gt;(t).set(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:ab07266bac81516113c418b4cb4994cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set. <br/></td></tr>
<tr class="separator:ab07266bac81516113c418b4cb4994cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4fa6d3cc8e817e30266700082336ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f4fa6d3cc8e817e30266700082336ff"></a>
template&lt;typename Name , typename Object , typename... Args&gt; </td></tr>
<tr class="memitem:a3f4fa6d3cc8e817e30266700082336ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a3f4fa6d3cc8e817e30266700082336ff">check</a> (Object const &amp;t, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a8c4a7dcd17a9cadde83d7ad91b7478ee">interface</a>&lt; Name &gt;(t).check(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a3f4fa6d3cc8e817e30266700082336ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check. <br/></td></tr>
<tr class="separator:a3f4fa6d3cc8e817e30266700082336ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162f7c6ad543d95f4f5acfb27cb3076b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a162f7c6ad543d95f4f5acfb27cb3076b"></a>
template&lt;typename Name , typename Object , typename... Args&gt; </td></tr>
<tr class="memitem:a162f7c6ad543d95f4f5acfb27cb3076b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a162f7c6ad543d95f4f5acfb27cb3076b">clear</a> (Object &amp;t, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceframework_1_1serializable.html#a8c4a7dcd17a9cadde83d7ad91b7478ee">interface</a>&lt; Name &gt;(t).clear(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a162f7c6ad543d95f4f5acfb27cb3076b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear. <br/></td></tr>
<tr class="separator:a162f7c6ad543d95f4f5acfb27cb3076b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9b390782cfcdff51c7720f693a0771"><td class="memTemplParams" colspan="2"><a class="anchor" id="acb9b390782cfcdff51c7720f693a0771"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:acb9b390782cfcdff51c7720f693a0771"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#acb9b390782cfcdff51c7720f693a0771">less</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:acb9b390782cfcdff51c7720f693a0771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than. <br/></td></tr>
<tr class="separator:acb9b390782cfcdff51c7720f693a0771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e48a8ad6b93a66562bddc89598d1f9e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e48a8ad6b93a66562bddc89598d1f9e"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:a6e48a8ad6b93a66562bddc89598d1f9e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a6e48a8ad6b93a66562bddc89598d1f9e">greater</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:a6e48a8ad6b93a66562bddc89598d1f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than. <br/></td></tr>
<tr class="separator:a6e48a8ad6b93a66562bddc89598d1f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af691f7bacf52c26ae993f292ce30a111"><td class="memTemplParams" colspan="2"><a class="anchor" id="af691f7bacf52c26ae993f292ce30a111"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:af691f7bacf52c26ae993f292ce30a111"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#af691f7bacf52c26ae993f292ce30a111">less_or_equal</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:af691f7bacf52c26ae993f292ce30a111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to. <br/></td></tr>
<tr class="separator:af691f7bacf52c26ae993f292ce30a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaba6758e294eb5e5961d9779a60fc16"><td class="memTemplParams" colspan="2"><a class="anchor" id="adaba6758e294eb5e5961d9779a60fc16"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:adaba6758e294eb5e5961d9779a60fc16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#adaba6758e294eb5e5961d9779a60fc16">greater_or_equal</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:adaba6758e294eb5e5961d9779a60fc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to. <br/></td></tr>
<tr class="separator:adaba6758e294eb5e5961d9779a60fc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff20e54f2382945ad4baba087867d110"><td class="memTemplParams" colspan="2"><a class="anchor" id="aff20e54f2382945ad4baba087867d110"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:aff20e54f2382945ad4baba087867d110"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#aff20e54f2382945ad4baba087867d110">equal</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:aff20e54f2382945ad4baba087867d110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to. <br/></td></tr>
<tr class="separator:aff20e54f2382945ad4baba087867d110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552ed9aec8f29fcfc6f532c59403622a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a552ed9aec8f29fcfc6f532c59403622a"></a>
template&lt;typename LhsType , typename RhsType &gt; </td></tr>
<tr class="memitem:a552ed9aec8f29fcfc6f532c59403622a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a552ed9aec8f29fcfc6f532c59403622a">not_equal</a> (LhsType const &amp;lhs, RhsType const &amp;rhs)</td></tr>
<tr class="memdesc:a552ed9aec8f29fcfc6f532c59403622a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal. <br/></td></tr>
<tr class="separator:a552ed9aec8f29fcfc6f532c59403622a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4a7dcd17a9cadde83d7ad91b7478ee"><td class="memTemplParams" colspan="2">template&lt;typename Name , typename Object &gt; </td></tr>
<tr class="memitem:a8c4a7dcd17a9cadde83d7ad91b7478ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a8c4a7dcd17a9cadde83d7ad91b7478ee">interface</a> (Object &amp;t) -&gt; <a class="el" href="namespaceframework_1_1serializable.html#a713b06731ae75399cacf92e1e71d9f0e">object_base</a>&lt; Object, Name &gt; &amp;</td></tr>
<tr class="separator:a8c4a7dcd17a9cadde83d7ad91b7478ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7356bd7cbf922ed693c4a94ce225d773"><td class="memTemplParams" colspan="2">template&lt;typename Name , typename Object &gt; </td></tr>
<tr class="memitem:a7356bd7cbf922ed693c4a94ce225d773"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a7356bd7cbf922ed693c4a94ce225d773">interface</a> (Object const &amp;t) -&gt; <a class="el" href="namespaceframework_1_1serializable.html#a713b06731ae75399cacf92e1e71d9f0e">object_base</a>&lt; Object, Name &gt; const &amp;</td></tr>
<tr class="separator:a7356bd7cbf922ed693c4a94ce225d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2525cd924620472daac0b2ebd3f5d4"><td class="memTemplParams" colspan="2">template&lt;typename Name , typename Specification , template&lt; typename &gt; class Interface, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:aba2525cd924620472daac0b2ebd3f5d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#aba2525cd924620472daac0b2ebd3f5d4">read_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1value__type.html">value_type</a>&lt; Name, Specification, Interface, true &gt; *, Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:aba2525cd924620472daac0b2ebd3f5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default read overload.  <a href="#aba2525cd924620472daac0b2ebd3f5d4">More...</a><br/></td></tr>
<tr class="separator:aba2525cd924620472daac0b2ebd3f5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022792eb84e9d45ef89c95ef1c575ae1"><td class="memTemplParams" colspan="2">template&lt;typename Name , typename Specification , template&lt; typename &gt; class Interface, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a022792eb84e9d45ef89c95ef1c575ae1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html#a022792eb84e9d45ef89c95ef1c575ae1">write_dispatch</a> (<a class="el" href="structframework_1_1serializable_1_1value__type.html">value_type</a>&lt; Name, Specification, Interface, true &gt; *, Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:a022792eb84e9d45ef89c95ef1c575ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default write overload.  <a href="#a022792eb84e9d45ef89c95ef1c575ae1">More...</a><br/></td></tr>
<tr class="separator:a022792eb84e9d45ef89c95ef1c575ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Serializable namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a94fc3006a12d9c2b44d6418201c09221"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">framework::serializable::container_children</a> = typedef typename detail::container_children_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a container type's children.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_container_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<a class="anchor" id="a66ef460625fe9bf758b9e13c8ee987b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a66ef460625fe9bf758b9e13c8ee987b8">framework::serializable::container_specification</a> = typedef typename detail::container_specification_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a container type's specification.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_container_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<a class="anchor" id="a7615226856136a967541b6d9e06587ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Specification&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a7615226856136a967541b6d9e06587ea">framework::serializable::custom_serializable</a> = typedef <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html">serializable_implementation</a> &lt; Derived, <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a66ef460625fe9bf758b9e13c8ee987b8">container_specification</a>&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a>&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a>&gt;, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation alias. </p>
<p>Custom <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html" title="Serializable implementation.">serializable_implementation</a> alias; no default marshalling functions are provided for the derived type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>derived class </td></tr>
    <tr><td class="paramname">Specification</td><td>child types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cf4ac1103ad890ccd680d232ae3acdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pack , template&lt; typename &gt; class Path&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">framework::serializable::extract_values</a> = typedef typename detail::extract_values_impl &lt;Pack, Path&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts value types. </p>
<p>Generates a <code><a class="el" href="structframework_1_1pack__container.html" title="Variadic pack container.">pack_container</a></code> of all value types accessible from <code>T</code>, using the <code>Path</code> template to define the child nodes of container types. For example, the following two result types are equivalent:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> result = <a class="code" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc" title="Extracts value types.">extract_values</a> &lt;</div>
<div class="line">    alias &lt;</div>
<div class="line">        value &lt;<a class="code" href="serializable_2common__macros_8hpp.html#a59c7737920212dcb3bb9df58d7062de4">NAME</a>(<span class="stringliteral">&quot;Field 1&quot;</span>), <span class="keywordtype">int</span>&gt;,</div>
<div class="line">        alias &lt;</div>
<div class="line">            value &lt;<a class="code" href="serializable_2common__macros_8hpp.html#a59c7737920212dcb3bb9df58d7062de4">NAME</a>(<span class="stringliteral">&quot;Field 2&quot;</span>), <span class="keywordtype">float</span>&gt;,</div>
<div class="line">            value &lt;<a class="code" href="serializable_2common__macros_8hpp.html#a59c7737920212dcb3bb9df58d7062de4">NAME</a>(<span class="stringliteral">&quot;Field 3&quot;</span>), <span class="keywordtype">double</span>&gt;&gt;,</div>
<div class="line">        value &lt;<a class="code" href="serializable_2common__macros_8hpp.html#a59c7737920212dcb3bb9df58d7062de4">NAME</a>(<span class="stringliteral">&quot;Field 4&quot;</span>), <span class="keywordtype">short</span>&gt;&gt;&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> result = pack_container &lt;</div>
<div class="line">    value &lt;<a class="code" href="serializable_2common__macros_8hpp.html#a59c7737920212dcb3bb9df58d7062de4">NAME</a>(<span class="stringliteral">&quot;Field 1&quot;</span>), <span class="keywordtype">int</span>&gt;,</div>
<div class="line">    value &lt;<a class="code" href="serializable_2common__macros_8hpp.html#a59c7737920212dcb3bb9df58d7062de4">NAME</a>(<span class="stringliteral">&quot;Field 2&quot;</span>), <span class="keywordtype">float</span>&gt;,</div>
<div class="line">    value &lt;<a class="code" href="serializable_2common__macros_8hpp.html#a59c7737920212dcb3bb9df58d7062de4">NAME</a>(<span class="stringliteral">&quot;Field 3&quot;</span>), <span class="keywordtype">double</span>&gt;,</div>
<div class="line">    value &lt;<a class="code" href="serializable_2common__macros_8hpp.html#a59c7737920212dcb3bb9df58d7062de4">NAME</a>(<span class="stringliteral">&quot;Field 4&quot;</span>), <span class="keywordtype">short</span>&gt;&gt;;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>container type </td></tr>
    <tr><td class="paramname">Path</td><td>path to follow through the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91ce35a788e129f1af53a71bec787d29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a91ce35a788e129f1af53a71bec787d29">framework::serializable::is_container_default_serializable</a> = typedef typename detail::is_container_default_serializable_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T is a default serializable <code>contaier_type</code>, equivalent to either std::true_type or std::false_type. </p>

</div>
</div>
<a class="anchor" id="abb7623c8ba8e228fec475ca249f3a890"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#abb7623c8ba8e228fec475ca249f3a890">framework::serializable::is_container_type</a> = typedef typename detail::is_container_type_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T is a <code><a class="el" href="structframework_1_1serializable_1_1container__type.html">container_type</a></code>, equivalent to either std::true_type or std::false_type. </p>

</div>
</div>
<a class="anchor" id="a4f55035b4c8eada5a8e683c6d49fdec1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a4f55035b4c8eada5a8e683c6d49fdec1">framework::serializable::is_mutator_type</a> = typedef typename detail::is_mutator_type_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T is a <code><a class="el" href="structframework_1_1serializable_1_1container__type.html">container_type</a></code>, equivalent to either std::true_type or std::false_type. </p>

</div>
</div>
<a class="anchor" id="a4b875688b6f74cafb34078cbf20a101f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a4b875688b6f74cafb34078cbf20a101f">framework::serializable::is_object_default_serializable</a> = typedef typename detail::is_object_default_serializable_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T is a default serializable <code><a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html" title="Serializable implementation.">serializable_implementation</a></code>, equivalent to either std::true_type or std::false_type. </p>

</div>
</div>
<a class="anchor" id="a9ff925ed4d0a4068e305966aa02a7421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a9ff925ed4d0a4068e305966aa02a7421">framework::serializable::is_object_type</a> = typedef typename detail::is_object_type_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T derives from <code><a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html" title="Serializable implementation.">serializable_implementation</a></code>, equivalent to either std::true_type or std::false_type. </p>

</div>
</div>
<a class="anchor" id="a22ae4dff8c1b786094991d385d805e4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a22ae4dff8c1b786094991d385d805e4f">framework::serializable::is_value_default_serializable</a> = typedef typename detail::is_value_type_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T is a default serializable <code><a class="el" href="structframework_1_1serializable_1_1value__type.html">value_type</a></code>, equivalent to either std::true_type or std::false_type. </p>

</div>
</div>
<a class="anchor" id="aacb1658f6947535ce4c60f585e186bd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#aacb1658f6947535ce4c60f585e186bd2">framework::serializable::is_value_type</a> = typedef typename detail::is_value_type_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T is a <code><a class="el" href="structframework_1_1serializable_1_1value__type.html">value_type</a></code>, equivalent to either std::true_type or std::false_type. </p>

</div>
</div>
<a class="anchor" id="a500fdba3155cccf9f4826d4f18f99a0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a500fdba3155cccf9f4826d4f18f99a0f">framework::serializable::mutator_child</a> = typedef typename detail::mutator_child_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a mutator's child type.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_mutator_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<a class="anchor" id="a713b06731ae75399cacf92e1e71d9f0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Name &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a713b06731ae75399cacf92e1e71d9f0e">framework::serializable::object_base</a> = typedef typename detail::object_base_impl &lt;T, Name&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the base type associated with <code>Name</code> in <code>T</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_derived_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<a class="anchor" id="a40e25409b4ac5207bede8f725e417452"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a40e25409b4ac5207bede8f725e417452">framework::serializable::object_names</a> = typedef typename detail::object_names_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a <code><a class="el" href="structframework_1_1pack__container.html" title="Variadic pack container.">pack_container</a></code> of every visible value name in <code>T</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_derived_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<a class="anchor" id="a4524878d84fde38e8dbf549177a7c6a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a4524878d84fde38e8dbf549177a7c6a3">framework::serializable::object_specification</a> = typedef typename detail::object_specification_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the specification associated with T.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_derived_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<a class="anchor" id="a7b717d04f56cc58bb9f27ceb31e273f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Specification&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a7b717d04f56cc58bb9f27ceb31e273f0">framework::serializable::serializable</a> = typedef <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html">serializable_implementation</a> &lt; Derived, <a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a66ef460625fe9bf758b9e13c8ee987b8">container_specification</a>&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a>&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a1cf4ac1103ad890ccd680d232ae3acdc">extract_values</a> &lt;<a class="el" href="structframework_1_1serializable_1_1alias.html">alias</a> &lt;Specification...&gt;, <a class="el" href="namespaceframework_1_1serializable.html#a94fc3006a12d9c2b44d6418201c09221">container_children</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation alias. </p>
<p>Default <a class="el" href="classframework_1_1serializable_1_1serializable__implementation.html" title="Serializable implementation.">serializable_implementation</a> alias.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>derived class </td></tr>
    <tr><td class="paramname">Specification</td><td>child types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60bcbbe8ff9188999b4be65b9bd06f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a60bcbbe8ff9188999b4be65b9bd06f64">framework::serializable::stl_null_wstring</a> = typedef <a class="el" href="structframework_1_1serializable_1_1terminated__container.html">terminated_container</a> &lt;<a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a> &lt;wchar_t&gt;, L'\0', std::wstring&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common STL wstring specification, null terminated. </p>
<dl class="section note"><dt>Note</dt><dd>This template uses little endian byte ordering to store individual characters - allowing this parameter to be user-specified here (ie: stl_wstring &lt;<code>Size</code>, <code>Value&gt;</code>) would introduce an implicit constraints or unusual mutator syntax. If this default is inadequate the <code>stl_null_basic_string</code> template should be used instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f51cdf6a41c7cc40fbe951b0da49823"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a0f51cdf6a41c7cc40fbe951b0da49823">framework::serializable::stl_wstring</a> = typedef <a class="el" href="structframework_1_1serializable_1_1variable__container.html">variable_container</a> &lt;Size, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">little_endian</a> &lt;wchar_t&gt;, std::wstring&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common STL wstring specification. </p>
<dl class="section note"><dt>Note</dt><dd>This template uses little endian byte ordering to store individual characters - allowing this parameter to be user-specified here (ie: stl_wstring &lt;<code>Size</code>, <code>Value&gt;</code>) would introduce an implicit constraints or unusual mutator syntax. If this default is inadequate the <code>stl_basic_string</code> template should be used instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a7441c447881d737be82d6c914a7830aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">framework::serializable::type_extractor</a> = typedef typename detail::type_extractor_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutator type extractor. </p>
<p>Extracts the underlying type, defined recursively as </p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> type_extractor &lt;typename get_mutator_child &lt;T&gt;::type&gt;::type</div>
</div><!-- fragment --><p> if <code>T</code> is a mutator type, and <code>T</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a0846f79acb10835a92abacd11ea6bdd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a0846f79acb10835a92abacd11ea6bdd5">framework::serializable::value_implementation</a> = typedef typename detail::value_implementation_impl &lt;T, Derived&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiates a value type's implementation with the parameter <code>Derived</code>, storing the result in <code>type</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_value_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<a class="anchor" id="a160c5b90af1270f9021ceaaa24e3b494"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a160c5b90af1270f9021ceaaa24e3b494">framework::serializable::value_name</a> = typedef typename detail::value_name_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a value type's name.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_value_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<a class="anchor" id="a537b4c9c082ffa1a9836f3fd38ed25fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1serializable.html#a537b4c9c082ffa1a9836f3fd38ed25fa">framework::serializable::value_specification</a> = typedef typename detail::value_specification_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a value type's specification.</p>
<dl class="section pre"><dt>Precondition</dt><dd>is_value_type &lt;T&gt;::value == true </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac3383ecea9cc1f5f7e4243b6fcbb60c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Specification , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto framework::serializable::dispatch_read </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>)</td><td></td>
          <td> -&gt; decltype(read_dispatch(
            static_cast &lt;Specification*&gt; (nullptr), 
            std::forward &lt;Args&gt; (args)...))
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatched read forwarder. </p>
<p>Uses the explicitly specified specification to serialize the object. </p>

</div>
</div>
<a class="anchor" id="a4ee613a7c1faaae8cf8731b5441c4be4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Specification , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto framework::serializable::dispatch_write </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>)</td><td></td>
          <td> -&gt; decltype(write_dispatch(
            static_cast &lt;Specification*&gt; (nullptr),
            std::forward &lt;Args&gt; (args)...))
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatched write forwarder. </p>
<p>Uses the explicitly specified specification to serialize the object. </p>

</div>
</div>
<a class="anchor" id="a8c4a7dcd17a9cadde83d7ad91b7478ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename Object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto framework::serializable::interface </td>
          <td>(</td>
          <td class="paramtype">Object &amp;&#160;</td>
          <td class="paramname"><em>t</em>)</td><td></td>
          <td> -&gt; object_base &lt;Object, Name&gt;&amp;
        </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the implementation associated with <code>Name</code> in <code>Object</code>. This method should be preferred over the get/set/... free functions when marshalling data; implementations may need to protect necessary methods. </p>

</div>
</div>
<a class="anchor" id="a7356bd7cbf922ed693c4a94ce225d773"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename Object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto framework::serializable::interface </td>
          <td>(</td>
          <td class="paramtype">Object const &amp;&#160;</td>
          <td class="paramname"><em>t</em>)</td><td></td>
          <td> -&gt; object_base &lt;Object, Name&gt; const&amp;
        </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a constant reference to the implementation associated with <code>Name</code> in <code>Object</code>. This method should be preferred over the get/set/... free functions when marshalling data; implementations may need to protect necessary methods. </p>

</div>
</div>
<a class="anchor" id="a093822d3d91e86e60cc948935e383fec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto framework::serializable::read </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(dispatch_read &lt;reference_base &lt;Output&gt;&gt; (
            std::forward &lt;Input&gt; (in),
            std::forward &lt;Output&gt; (out)))
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read forwarder. </p>
<p>Uses the output object's type as it's specification, generally equivalent to:</p>
<div class="fragment"><div class="line">read &lt;decltype(out)&gt; (in, out);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad384421d3632342e453a7a2eec0c2e39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output , typename Block , typename... Specification&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">bit_field&lt; Block, Specification...&gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aab0febf21d62b3c2612c6a0697cf5ef0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , typename Container , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">fixed_container&lt; Value, Container &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a362430520160e5538c743c2ec765c6f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , type_extractor&lt; Value &gt; Terminator, typename Container , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">terminated_container&lt; Value, Terminator, Container &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<p>Reads elements into <code>out</code> from the input stream using the specification given by <code>Value</code> until the value read matches <code>Terminator</code>. The terminating character is not added to <code>out</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a39e2278fc3735281805887007034b7df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Parameters, typename Container , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">tuple_container&lt; pack_container&lt; Parameters...&gt;, Container &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<p>Reads the container's elements from an input stream using the specification list <code>Parameters</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a018ab772f5ac35da248579c52180b3f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Size , typename Value , typename Container , bool Continuous, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">variable_container&lt; Size, Value, Container, Continuous &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<p>Reads the container from an input stream as a size delimited list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad5f1483c270b49df99f76543e3130a29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">little_endian&lt; T &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<p>Reads a value of type T from an input stream using little endian byte ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69252a82c239399bc1d38530e6c621a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Value , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">bit_value&lt; N, Value &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a984713cd5500fda66fe4634bfa16b526"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">big_endian&lt; T &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<p>Reads a value of type T from an input stream using big endian byte ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbc1129b592acb769ea50eb212a3d524"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Specification, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">optional_field&lt; Type, Specification...&gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a2430a4654eb64e100857486ab1c02896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Size , typename Value , typename Container , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> std::enable_if&lt; std::is_same &lt;Value, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a> &lt;Value&gt; &gt;::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a> &amp;&amp; std::is_scalar &lt;Value&gt;::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a>, bool &gt;::type framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">variable_container&lt; Size, Value, Container, true &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block read overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a1fbd87663a2ce7a6f2caf71b882d07bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Specification , typename Children , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">container_type&lt; Specification, Children, true &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default read overload. </p>
<p>Serializes each element of container_children &lt;Specification&gt; in the order it appears.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>deserialization arguments, usually an input stream followed by an output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a47ce72aea2369fb39049f532023f7b38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">pdp_endian&lt; T &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<p>Reads a value of type T from an input stream using pdp endian byte ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba2525cd924620472daac0b2ebd3f5d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename Specification , template&lt; typename &gt; class Interface, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">value_type&lt; Name, Specification, Interface, true &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default read overload. </p>
<dl class="section note"><dt>Note</dt><dd>The field's underlying value type must be default constructable with an associated implementation supporting move semantics through it's set method.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>the call succeeds or out is not altered </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a583d230ea0e1e1a0b0646b0bffb3b6f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Flag, typename Name , typename Specification , template&lt; typename &gt; class Implementation, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::read_dispatch </td>
          <td>(</td>
          <td class="paramtype">optional_value&lt; Flag, Name, Specification, Implementation &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read overload. </p>
<p>Conditionally reads the underlying value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="acf40b80e08e58e843ac0fb050c468cab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::stream_read </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream read forwarder. </p>
<p>Used to forward a fixed-byte read call to the underlying stream object. Equivalent to one of the following two calls, in order of precedence:</p>
<div class="fragment"><div class="line">s.read &lt;N&gt; (reinterpret_cast &lt;<span class="keywordtype">char</span>*&gt; (out));</div>
<div class="line">s.read(reinterpret_cast &lt;char*&gt; (out), N);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa9e49254100130f450167d1b5c70aed7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::stream_read </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream read forwarder. </p>
<p>Used to forward a fixed-byte read call to the underlying stream object. Equivalent to the following:</p>
<div class="fragment"><div class="line">s.read(reinterpret_cast &lt;char*&gt; (out), N);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2def8034de5c04de173ee8da33a0da09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::stream_write </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream write forwarder. </p>
<p>Used to forward a fixed-byte write call to the underlying stream object. Equivalent to one of the following two calls, in order of precedence:</p>
<div class="fragment"><div class="line">s.write &lt;N&gt; (reinterpret_cast &lt;<span class="keywordtype">char</span> <span class="keyword">const</span>*&gt; (out));</div>
<div class="line">s.write(reinterpret_cast &lt;char const*&gt; (out), N);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1ff339264ca138bd9d60413bf3cf201a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::stream_write </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream write forwarder. </p>
<p>Used to forward a fixed-byte write call to the underlying stream object. Equivalent to the following:</p>
<div class="fragment"><div class="line">s.write &lt;N&gt; (reinterpret_cast &lt;<span class="keywordtype">char</span> <span class="keyword">const</span>*&gt; (out));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8c411f3a0194a69a374492044f2fcea0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto framework::serializable::write </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(dispatch_write &lt;reference_base &lt;Input&gt;&gt; (
            std::forward &lt;Input&gt; (in),
            std::forward &lt;Output&gt; (out)))
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write forwarder. </p>
<p>Uses the input object's type as it's specification. </p>

</div>
</div>
<a class="anchor" id="a70cea0667671aa34b7e5e87ee1a38617"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output , typename Block , typename... Specification&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">bit_field&lt; Block, Specification...&gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="abab51978b9416c9abef1e4112ed0f4f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , typename Container , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">fixed_container&lt; Value, Container &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input container </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ae3f989b96f85125f40c319c9aa978d7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Parameters, typename Container , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">tuple_container&lt; pack_container&lt; Parameters...&gt;, Container &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<p>Wries the container's elements to an output stream using the specification list <code>Parameters</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input container </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a2eb11c7a99b282a94927fc94e61a7179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">little_endian&lt; T &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<p>Writes a value of type T to an output stream using little endian byte ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input value </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bcaa1d92b698abf080d6972392547c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , type_extractor&lt; Value &gt; Terminator, typename Container , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">terminated_container&lt; Value, Terminator, Container &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<p>Writes elements to the output stream from <code>in</code> using the specification given by <code>Value</code> until the value matches <code>Terminator</code>. The terminating character is not added to <code>out</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><img class="formulaInl" alt="$x \ne \textbf{Terminator}, \forall x \in \textbf{in}$" src="form_0.png"/> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input container </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a3fa84fe9ee6e886610c0d4d79d2473bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Size , typename Value , typename Container , bool Continuous, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">variable_container&lt; Size, Value, Container, Continuous &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<p>Writes the container to an output stream as a size delimited list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ac8e897d843f8a319b443b8fdc92dec94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Value , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">bit_value&lt; N, Value &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input value </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad70ffbf4b31750786e8a82ea76e0d9a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">big_endian&lt; T &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<p>Writes a value of type T to an output stream using big endian byte ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input value </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3585a25c97ba8c548f4816dd896e8e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Specification, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">optional_field&lt; Type, Specification...&gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a1c628660258f76477013850124a1e0c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Specification , typename Children , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">container_type&lt; Specification, Children, true &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default write overload. </p>
<p>Serializes each element of container_children &lt;Specification&gt; in the order it appears.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>serialization arguments, usually an input container followed by an output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a53424ccfbee253f0f0c6ecdc9b553070"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Size , typename Value , typename Container , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> std::enable_if&lt; std::is_same &lt;Value, <a class="el" href="namespaceframework_1_1serializable.html#a7441c447881d737be82d6c914a7830aa">type_extractor</a> &lt;Value&gt; &gt;::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a> &amp;&amp; std::is_scalar &lt;Value&gt;::<a class="el" href="structframework_1_1serializable_1_1value.html">value</a>, bool &gt;::type framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">variable_container&lt; Size, Value, Container, true &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block write overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a022792eb84e9d45ef89c95ef1c575ae1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename Specification , template&lt; typename &gt; class Interface, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">value_type&lt; Name, Specification, Interface, true &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default write overload. </p>
<dl class="section post"><dt>Postcondition</dt><dd>the call succeeds or out is not altered </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a348cc209ccb5a2958f690e9489b255ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">pdp_endian&lt; T &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<p>Writes a value of type T to an output stream using pdp endian byte ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input value </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79eabc02808d7139ddd4d218160ebf7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Flag, typename Name , typename Specification , template&lt; typename &gt; class Implementation, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">optional_value&lt; Flag, Name, Specification, Implementation &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<p>Conditionally writes the underlying value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ac44e43094d0b96fe5d1bb118af59e094"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Flag, typename Name , typename Specification , template&lt; typename &gt; class Implementation, typename Input , typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::serializable::write_dispatch </td>
          <td>(</td>
          <td class="paramtype">optional_value&lt; Flag, Name, Specification, Implementation &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">output_flags_frame&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write overload. </p>
<p>Writes the object state to a flags stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 10 2013 20:49:42 for framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1-20130402
</small></address>
</body>
</html>
