<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1-20130402"/>
<title>framework: framework Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1-20130402 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">framework Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Framework namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceframework_1_1protocol__buffers"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html">protocol_buffers</a></td></tr>
<tr class="memdesc:namespaceframework_1_1protocol__buffers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol buffers namespace. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceframework_1_1serializable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1serializable.html">serializable</a></td></tr>
<tr class="memdesc:namespaceframework_1_1serializable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializable namespace. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1pack__container.html">pack_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic pack container.  <a href="structframework_1_1pack__container.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1type__string.html">type_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type string.  <a href="structframework_1_1type__string.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae0f241cac2ef52882675b3fe2d56868d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0f241cac2ef52882675b3fe2d56868d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#ae0f241cac2ef52882675b3fe2d56868d">is_pack_container</a> = typename detail::is_pack_container&lt; T &gt;::type</td></tr>
<tr class="separator:ae0f241cac2ef52882675b3fe2d56868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92c762258c9b7850807a7baba060ae1"><td class="memTemplParams" colspan="2">template&lt;typename... Packs&gt; </td></tr>
<tr class="memitem:ac92c762258c9b7850807a7baba060ae1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#ac92c762258c9b7850807a7baba060ae1">merge_packs</a> = typename detail::merge_packs_impl&lt; Packs...&gt;::type</td></tr>
<tr class="memdesc:ac92c762258c9b7850807a7baba060ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge parameter packs.  <a href="#ac92c762258c9b7850807a7baba060ae1">More...</a><br/></td></tr>
<tr class="separator:ac92c762258c9b7850807a7baba060ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e6e533750ce54b2da4124a100ea520"><td class="memTemplParams" colspan="2">template&lt;typename Pack , template&lt; typename &gt; class Matcher&gt; </td></tr>
<tr class="memitem:a40e6e533750ce54b2da4124a100ea520"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a40e6e533750ce54b2da4124a100ea520">filter_pack</a> = typename detail::filter_pack_impl&lt; Pack, Matcher &gt;::type</td></tr>
<tr class="memdesc:a40e6e533750ce54b2da4124a100ea520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter pack filter.  <a href="#a40e6e533750ce54b2da4124a100ea520">More...</a><br/></td></tr>
<tr class="separator:a40e6e533750ce54b2da4124a100ea520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54912c2201a72828b6423f3b4ac48ac2"><td class="memTemplParams" colspan="2">template&lt;typename Values , template&lt; typename &gt; class Matcher&gt; </td></tr>
<tr class="memitem:a54912c2201a72828b6423f3b4ac48ac2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a54912c2201a72828b6423f3b4ac48ac2">unique_filter_pack</a> = typename detail::unique_filter_pack_impl&lt; <a class="el" href="namespaceframework.html#a40e6e533750ce54b2da4124a100ea520">filter_pack</a>&lt; Values, Matcher &gt;&gt;::type</td></tr>
<tr class="memdesc:a54912c2201a72828b6423f3b4ac48ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique parameter pack filter.  <a href="#a54912c2201a72828b6423f3b4ac48ac2">More...</a><br/></td></tr>
<tr class="separator:a54912c2201a72828b6423f3b4ac48ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991d6c2a5fdf87576fc8d4a30b37f36e"><td class="memTemplParams" colspan="2">template&lt;typename Pack , template&lt; typename &gt; class Matcher, std::size_t Position = 0&gt; </td></tr>
<tr class="memitem:a991d6c2a5fdf87576fc8d4a30b37f36e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a991d6c2a5fdf87576fc8d4a30b37f36e">find_pack</a> = std::integral_constant&lt; std::size_t, detail::find_pack_impl&lt; Pack, Matcher, Position &gt;::value &gt;</td></tr>
<tr class="memdesc:a991d6c2a5fdf87576fc8d4a30b37f36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find type.  <a href="#a991d6c2a5fdf87576fc8d4a30b37f36e">More...</a><br/></td></tr>
<tr class="separator:a991d6c2a5fdf87576fc8d4a30b37f36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563bad81e0dc0c7eea5ae1377152c08b"><td class="memTemplParams" colspan="2">template&lt;typename Lhs , typename Rhs &gt; </td></tr>
<tr class="memitem:a563bad81e0dc0c7eea5ae1377152c08b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a563bad81e0dc0c7eea5ae1377152c08b">value_less_than</a> = typename detail::value_less_than_impl&lt; Lhs, Rhs &gt;::type</td></tr>
<tr class="memdesc:a563bad81e0dc0c7eea5ae1377152c08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value less than.  <a href="#a563bad81e0dc0c7eea5ae1377152c08b">More...</a><br/></td></tr>
<tr class="separator:a563bad81e0dc0c7eea5ae1377152c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a5e075dd56717ec339cbd7dda359fd"><td class="memTemplParams" colspan="2">template&lt;typename Pack , template&lt; typename, typename &gt; class LessThan = value_less_than&gt; </td></tr>
<tr class="memitem:a96a5e075dd56717ec339cbd7dda359fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a96a5e075dd56717ec339cbd7dda359fd">sort_pack</a> = typename detail::sort_pack_impl&lt; Pack, LessThan &gt;::type</td></tr>
<tr class="memdesc:a96a5e075dd56717ec339cbd7dda359fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort pack.  <a href="#a96a5e075dd56717ec339cbd7dda359fd">More...</a><br/></td></tr>
<tr class="separator:a96a5e075dd56717ec339cbd7dda359fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4be74470e7d03cabceeb8e74d3e881"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Size&gt; </td></tr>
<tr class="memitem:a0f4be74470e7d03cabceeb8e74d3e881"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a0f4be74470e7d03cabceeb8e74d3e881">make_values</a> = typename detail::make_values_impl&lt; Type, Size &gt;::type</td></tr>
<tr class="memdesc:a0f4be74470e7d03cabceeb8e74d3e881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic case container constructor.  <a href="#a0f4be74470e7d03cabceeb8e74d3e881">More...</a><br/></td></tr>
<tr class="separator:a0f4be74470e7d03cabceeb8e74d3e881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fc5472c2b78654187063bc35a588a1"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size&gt; </td></tr>
<tr class="memitem:a87fc5472c2b78654187063bc35a588a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a87fc5472c2b78654187063bc35a588a1">make_indices</a> = typename detail::make_values_impl&lt; std::size_t, Size &gt;::type</td></tr>
<tr class="memdesc:a87fc5472c2b78654187063bc35a588a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index container constructor.  <a href="#a87fc5472c2b78654187063bc35a588a1">More...</a><br/></td></tr>
<tr class="separator:a87fc5472c2b78654187063bc35a588a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caf4c9a3275bfe98b0a79bac60fa515"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3caf4c9a3275bfe98b0a79bac60fa515"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a3caf4c9a3275bfe98b0a79bac60fa515">is_type_string</a> = typename detail::is_type_string_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a3caf4c9a3275bfe98b0a79bac60fa515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4424508bbb28331ba4305ae9753ce049"><td class="memTemplParams" colspan="2">template&lt;char... Array&gt; </td></tr>
<tr class="memitem:a4424508bbb28331ba4305ae9753ce049"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a4424508bbb28331ba4305ae9753ce049">make_type_string</a> = typename detail::make_type_string_impl&lt; Array...&gt;::type</td></tr>
<tr class="memdesc:a4424508bbb28331ba4305ae9753ce049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make type string.  <a href="#a4424508bbb28331ba4305ae9753ce049">More...</a><br/></td></tr>
<tr class="separator:a4424508bbb28331ba4305ae9753ce049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab8dd0e8c38c5a1de4050f1eed2c57c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ab8dd0e8c38c5a1de4050f1eed2c57c"></a>
template&lt;typename... Strings&gt; </td></tr>
<tr class="memitem:a7ab8dd0e8c38c5a1de4050f1eed2c57c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a7ab8dd0e8c38c5a1de4050f1eed2c57c">merge_strings</a> = typename detail::merge_strings_impl&lt; Strings...&gt;::type</td></tr>
<tr class="memdesc:a7ab8dd0e8c38c5a1de4050f1eed2c57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge type strings. <br/></td></tr>
<tr class="separator:a7ab8dd0e8c38c5a1de4050f1eed2c57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a684c4da52f6db239f390e3d4f00ee474"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a684c4da52f6db239f390e3d4f00ee474">byte_order</a> </td></tr>
<tr class="memdesc:a684c4da52f6db239f390e3d4f00ee474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte order alias.  <a href="namespaceframework.html#a684c4da52f6db239f390e3d4f00ee474">More...</a><br/></td></tr>
<tr class="separator:a684c4da52f6db239f390e3d4f00ee474"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9187399d61610b50b3dd8cd87b866aa7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9187399d61610b50b3dd8cd87b866aa7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9187399d61610b50b3dd8cd87b866aa7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a9187399d61610b50b3dd8cd87b866aa7">bswap16</a> (T &amp;&amp;in)</td></tr>
<tr class="memdesc:a9187399d61610b50b3dd8cd87b866aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common 16-bit byte swap implementation. <br/></td></tr>
<tr class="separator:a9187399d61610b50b3dd8cd87b866aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b629f55c07d433f71b35dcf74bea2fa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b629f55c07d433f71b35dcf74bea2fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b629f55c07d433f71b35dcf74bea2fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a4b629f55c07d433f71b35dcf74bea2fa">bswap32</a> (T &amp;&amp;in)</td></tr>
<tr class="memdesc:a4b629f55c07d433f71b35dcf74bea2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common 32-bit byte swap implementation. <br/></td></tr>
<tr class="separator:a4b629f55c07d433f71b35dcf74bea2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98ec8b98d1abf3558da42939a0f8d2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa98ec8b98d1abf3558da42939a0f8d2d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa98ec8b98d1abf3558da42939a0f8d2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#aa98ec8b98d1abf3558da42939a0f8d2d">bswap64</a> (T &amp;&amp;in)</td></tr>
<tr class="memdesc:aa98ec8b98d1abf3558da42939a0f8d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common 64-bit byte swap implementation. <br/></td></tr>
<tr class="separator:aa98ec8b98d1abf3558da42939a0f8d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281253bc03386001f3cab27f54185daa"><td class="memTemplParams" colspan="2">template&lt;typename CaseList , typename Handler , typename Index , typename... Args&gt; </td></tr>
<tr class="memitem:a281253bc03386001f3cab27f54185daa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a281253bc03386001f3cab27f54185daa">variadic_switch_fallthrough</a> (Handler &amp;&amp;handler, Index &amp;&amp;index, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a281253bc03386001f3cab27f54185daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic switch (fall-through).  <a href="#a281253bc03386001f3cab27f54185daa">More...</a><br/></td></tr>
<tr class="separator:a281253bc03386001f3cab27f54185daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16278f1adf9dcf356623ed29254294cc"><td class="memTemplParams" colspan="2">template&lt;typename CaseList , typename Handler , typename Index , typename... Args&gt; </td></tr>
<tr class="memitem:a16278f1adf9dcf356623ed29254294cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a16278f1adf9dcf356623ed29254294cc">variadic_switch_return</a> (Handler &amp;&amp;handler, Index &amp;&amp;index, Args &amp;&amp;...args) -&gt; decltype(handler(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a16278f1adf9dcf356623ed29254294cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic switch (return).  <a href="#a16278f1adf9dcf356623ed29254294cc">More...</a><br/></td></tr>
<tr class="separator:a16278f1adf9dcf356623ed29254294cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0b4e449bd50dc2ae707c499620306b"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd0b4e449bd50dc2ae707c499620306b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd0b4e449bd50dc2ae707c499620306b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#afd0b4e449bd50dc2ae707c499620306b">wswap32</a> (T &amp;&amp;in)</td></tr>
<tr class="memdesc:afd0b4e449bd50dc2ae707c499620306b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common 32-bit word swap implementation. <br/></td></tr>
<tr class="separator:afd0b4e449bd50dc2ae707c499620306b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39746721c90fb51418be6ef4e02ae7db"><td class="memTemplParams" colspan="2"><a class="anchor" id="a39746721c90fb51418be6ef4e02ae7db"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39746721c90fb51418be6ef4e02ae7db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework.html#a39746721c90fb51418be6ef4e02ae7db">wswap64</a> (T &amp;&amp;in)</td></tr>
<tr class="memdesc:a39746721c90fb51418be6ef4e02ae7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common 64-bit word swap implementation. <br/></td></tr>
<tr class="separator:a39746721c90fb51418be6ef4e02ae7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Framework namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a40e6e533750ce54b2da4124a100ea520"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pack , template&lt; typename &gt; class Matcher&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a40e6e533750ce54b2da4124a100ea520">framework::filter_pack</a> = typedef typename detail::filter_pack_impl &lt;Pack, Matcher&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameter pack filter. </p>
<p>Constructs a <code><a class="el" href="structframework_1_1pack__container.html" title="Variadic pack container.">pack_container</a></code> of elements <code>T</code> of <code>Pack</code> satisfying</p>
<div class="fragment"><div class="line">Matcher &lt;T&gt;::value == <span class="keyword">true</span></div>
</div><!-- fragment --><p>storing the result int <code>type</code>. For example, the following are equivalent:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> results = filter_pack &lt;pack_container &lt;int, float, short, double, int&gt;, std::is_integral&gt;;</div>
<div class="line"><span class="keyword">using</span> results = pack_container &lt;int, short, int&gt;;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a991d6c2a5fdf87576fc8d4a30b37f36e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pack , template&lt; typename &gt; class Matcher, std::size_t Position = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a991d6c2a5fdf87576fc8d4a30b37f36e">framework::find_pack</a> = typedef std::integral_constant &lt;std::size_t, detail::find_pack_impl &lt;Pack, Matcher, Position&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find type. </p>
<p>Obtains the index of the first element of Pack satisfying:</p>
<div class="fragment"><div class="line">index &gt;= Position &amp;&amp; Matcher &lt;T&gt;::value == <span class="keyword">true</span></div>
</div><!-- fragment --><p>storing the result in value. If no such element exists, std::basic_string::npos is returned instead. </p>

</div>
</div>
<a class="anchor" id="ae0f241cac2ef52882675b3fe2d56868d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#ae0f241cac2ef52882675b3fe2d56868d">framework::is_pack_container</a> = typedef typename detail::is_pack_container &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T is a <a class="el" href="structframework_1_1pack__container.html" title="Variadic pack container.">pack_container</a>. </p>

</div>
</div>
<a class="anchor" id="a3caf4c9a3275bfe98b0a79bac60fa515"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a3caf4c9a3275bfe98b0a79bac60fa515">framework::is_type_string</a> = typedef typename detail::is_type_string_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type trait testing whether or not T is a <code><a class="el" href="structframework_1_1type__string.html" title="Type string.">type_string</a></code>. </p>

</div>
</div>
<a class="anchor" id="a87fc5472c2b78654187063bc35a588a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a87fc5472c2b78654187063bc35a588a1">framework::make_indices</a> = typedef typename detail::make_values_impl &lt;std::size_t, Size&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index container constructor. </p>
<p>Creates an index_container containing the elements [0, Size). The following are equivalent:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> result = make_indices &lt;3&gt;;</div>
<div class="line"><span class="keyword">using</span> result = make_values &lt;std::size_t, 3&gt;;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4424508bbb28331ba4305ae9753ce049"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;char... Array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a4424508bbb28331ba4305ae9753ce049">framework::make_type_string</a> = typedef typename detail::make_type_string_impl &lt;Array...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make type string. </p>
<p>Constructs a type string from a <code>'\0'</code> terminated sequence of input characters, providing a reduced type string in <code>type</code>. The following are equivalent:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> result = make_type_string &lt;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;!&#39;, &#39;\0&#39;, &#39;\0&#39;&gt;;</div>
<div class="line"><span class="keyword">using</span> result = type_string &lt;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;!&#39;&gt;;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0f4be74470e7d03cabceeb8e74d3e881"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a0f4be74470e7d03cabceeb8e74d3e881">framework::make_values</a> = typedef typename detail::make_values_impl &lt;Type, Size&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic case container constructor. </p>
<p>Creates a value_container containing the elements [0, Size). The following are equivalent:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> result = make_values &lt;std::size_t, 3&gt;;</div>
<div class="line"><span class="keyword">using</span> result = pack_container &lt;</div>
<div class="line">    integral_constant &lt;std::size_t, 0&gt;, </div>
<div class="line">    integral_constant &lt;std::size_t, 1&gt;, </div>
<div class="line">    integral_constant &lt;std::size_t, 2&gt;&gt;;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac92c762258c9b7850807a7baba060ae1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Packs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#ac92c762258c9b7850807a7baba060ae1">framework::merge_packs</a> = typedef typename detail::merge_packs_impl &lt;Packs...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge parameter packs. </p>
<p>Constructs a parameter pack containing all elements of the pack containers provided in <code>Packs</code>, in the order they appear. For example, the following are equivalent:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> results = merge_packs &lt;pack_container &lt;int, float&gt;, pack_container &lt;double&gt;&gt;;</div>
<div class="line"><span class="keyword">using</span> results = pack_container &lt;int, float, double&gt;;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Packs</td><td>input <code><a class="el" href="structframework_1_1pack__container.html" title="Variadic pack container.">pack_container</a></code> types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96a5e075dd56717ec339cbd7dda359fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pack , template&lt; typename, typename &gt; class LessThan = value_less_than&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a96a5e075dd56717ec339cbd7dda359fd">framework::sort_pack</a> = typedef typename detail::sort_pack_impl &lt;Pack, LessThan&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort pack. </p>
<p>Sorts the pack using the provided less than operator. </p>

</div>
</div>
<a class="anchor" id="a54912c2201a72828b6423f3b4ac48ac2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Values , template&lt; typename &gt; class Matcher&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a54912c2201a72828b6423f3b4ac48ac2">framework::unique_filter_pack</a> = typedef typename detail::unique_filter_pack_impl &lt;<a class="el" href="namespaceframework.html#a40e6e533750ce54b2da4124a100ea520">filter_pack</a> &lt;Values, Matcher&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique parameter pack filter. </p>
<p>Obtains the unique element <code>T</code> of <code>Pack</code> satisfying </p>
<div class="fragment"><div class="line">Match &lt;T&gt;::value == <span class="keyword">true</span></div>
</div><!-- fragment --><p>storing the result in <code>type</code>. For example, the following are equivalent:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> result = unique_filter_pack &lt;pack_container &lt;short, double, int, long&gt;, std::is_floating_point&gt;;</div>
<div class="line"><span class="keyword">using</span> result = double;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a563bad81e0dc0c7eea5ae1377152c08b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs , typename Rhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework.html#a563bad81e0dc0c7eea5ae1377152c08b">framework::value_less_than</a> = typedef typename detail::value_less_than_impl &lt;Lhs, Rhs&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value less than. </p>
<p>The following are equivalent: </p>
<div class="fragment"><div class="line"><span class="keyword">enum</span>{ result = value_less_than &lt;Lhs, Rhs&gt;::value };</div>
<div class="line"><span class="keyword">enum</span>{ result = Lhs::value &lt; Rhs::value ? <span class="keyword">true</span> : <span class="keyword">false</span> };</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a684c4da52f6db239f390e3d4f00ee474"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceframework.html#a684c4da52f6db239f390e3d4f00ee474">framework::byte_order</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Byte order alias. </p>
<p>Provides a series of enum values that may be used in place of the preprocessor definitions above. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a281253bc03386001f3cab27f54185daa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CaseList , typename Handler , typename Index , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> void framework::variadic_switch_fallthrough </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic switch (fall-through). </p>
<p>Expands a variadic case list into a switch statement in groups of <code>FRAMEWORK_VARIADIC_SWITCH_LIMIT</code> elements. This variant falls-through subsequent cases on success - for example, given a limit of 5 or higher, the following call to <code>variadic_switch_fallthrough:</code> </p>
<div class="fragment"><div class="line">variadic_switch_fallthrough &lt;make_indices &lt;5&gt;&gt; (f, i);</div>
</div><!-- fragment --><p>is equivalent to the following switch statement:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">case</span> 0: f.operator() &lt;0&gt; ();</div>
<div class="line">    <span class="keywordflow">case</span> 1: f.operator() &lt;1&gt; ();</div>
<div class="line">    <span class="keywordflow">case</span> 2: f.operator() &lt;2&gt; ();</div>
<div class="line">    <span class="keywordflow">case</span> 3: f.operator() &lt;3&gt; ();</div>
<div class="line">    <span class="keywordflow">case</span> 4: f.operator() &lt;4&gt; ();</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">default</span>: f();</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CaseList</td><td>switch case list </td></tr>
    <tr><td class="paramname">Handler</td><td>handler functor type </td></tr>
    <tr><td class="paramname">Args</td><td>argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>switch statement index </td></tr>
    <tr><td class="paramname">handler</td><td>handler functor </td></tr>
    <tr><td class="paramname">args</td><td>functor arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16278f1adf9dcf356623ed29254294cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CaseList , typename Handler , typename Index , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> auto framework::variadic_switch_return </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(handler(std::forward &lt;Args&gt; (args)...))
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic switch (return). </p>
<p>Expands a variadic case list into a switch statement in groups of FRAMEWORK_VARIADIC_SWITCH_LIMIT elements. This variant returns the result of the appropriate function call on success - for example, given a limit of 2 the following call to variadic_switch_return:</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> variadic_switch_return &lt;make_indices &lt;5&gt;&gt; (f, i);</div>
</div><!-- fragment --><p>is equivalent to the following series of switch statements:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">case</span> 0: <span class="keywordflow">return</span> f.operator() &lt;0&gt; ();</div>
<div class="line">    <span class="keywordflow">case</span> 1: <span class="keywordflow">return</span> f.operator() &lt;1&gt; ();</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">      <span class="keywordflow">switch</span> (i)</div>
<div class="line">      {</div>
<div class="line">          <span class="keywordflow">case</span> 2: <span class="keywordflow">return</span> f.operator() &lt;2&gt; ();</div>
<div class="line">          <span class="keywordflow">case</span> 3: <span class="keywordflow">return</span> f.operator() &lt;3&gt; ();</div>
<div class="line">          <span class="keywordflow">default</span>:</div>
<div class="line">              <span class="keywordflow">switch</span> (i)</div>
<div class="line">              {</div>
<div class="line">                  <span class="keywordflow">case</span> 4: <span class="keywordflow">return</span> f.operator &lt;4&gt; ();</div>
<div class="line">                  <span class="keywordflow">default</span>: <span class="keywordflow">return</span> f();</div>
<div class="line">              }</div>
<div class="line">      }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CaseList</td><td>switch case list </td></tr>
    <tr><td class="paramname">Handler</td><td>handler functor type </td></tr>
    <tr><td class="paramname">Args</td><td>argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>switch statement index </td></tr>
    <tr><td class="paramname">handler</td><td>handler functor </td></tr>
    <tr><td class="paramname">args</td><td>functor arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 10 2013 20:49:42 for framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1-20130402
</small></address>
</body>
</html>
