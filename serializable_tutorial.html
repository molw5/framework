<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.2-20121118"/>
<title>framework: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2-20121118 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Mainpage documentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#serializable_simple">A simple example</a></li>
<li class="level1"><a href="#serializable_portable">A portable example</a></li>
<li class="level1"><a href="#serializable_custom_structures">Custom structures</a></li>
<li class="level1"><a href="#serializable_custom_implementation">Custom implementations</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="serializable_simple"></a>
A simple example</h1>
<p>The code provided in <code>a_simple_example.cpp</code> demonstrates the simplest possible use case for this library - a basic structure is defined, serialized, and deserialized.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serializable_8hpp.html" title="Common serializable includes.">framework/serializable.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stl__string_8hpp.html" title="Common STL string aliases.">framework/serializable/mutators/stl_string.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">    using ::framework::serializable::inline_object;</div>
<div class="line">    <a class="code" href="namespaceframework_1_1serializable.html#afbe4dd751b45a97c4651ab711fb24bac" title="Common STL string specification, null terminated.">using ::framework::serializable::stl_null_string</a>;</div>
<div class="line">    using ::framework::serializable::value;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Define an object type</span></div>
<div class="line">    <span class="keyword">using</span> <span class="keywordtype">object</span> = inline_object &lt;</div>
<div class="line">        value &lt;NAME(<span class="stringliteral">&quot;Field 1&quot;</span>), int32_t&gt;,</div>
<div class="line">        value &lt;NAME(<span class="stringliteral">&quot;Field 2&quot;</span>), <span class="keywordtype">double</span>&gt;,</div>
<div class="line">        value &lt;NAME(<span class="stringliteral">&quot;Field 3&quot;</span>), <a class="code" href="namespaceframework_1_1serializable.html#afbe4dd751b45a97c4651ab711fb24bac" title="Common STL string specification, null terminated.">stl_null_string</a>&gt;&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create an object</span></div>
<div class="line">    <span class="keywordtype">object</span> o1 {1, 2.0, <span class="stringliteral">&quot;Hello World!&quot;</span>};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Write the object to a file</span></div>
<div class="line">    assert(<a class="code" href="namespaceframework_1_1serializable.html#a99b0af2f2f45ba69a1d6b7c7fc2dbb5e" title="Write forwarder.">write</a>(o1, std::ofstream(<span class="stringliteral">&quot;filename&quot;</span>)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read the object from a file</span></div>
<div class="line">    <span class="keywordtype">object</span> o2;</div>
<div class="line">    assert(<a class="code" href="namespaceframework_1_1serializable.html#a116938beb8e2e5e17ac3029a7b5c2e60" title="Read fowarder.">read</a>(std::ifstream(<span class="stringliteral">&quot;filename&quot;</span>), o2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check the result</span></div>
<div class="line">    assert(o1 == o2);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>"filename" output:</p>
<div class="fragment"><div class="line">0000000: 0100 0000 0000 0000 0000 0040 4865 6c6c  ...........@Hell</div>
<div class="line">0000010: 6f20 576f 726c 6421 00                   o World!.</div>
</div><!-- fragment --><h1><a class="anchor" id="serializable_portable"></a>
A portable example</h1>
<p>The example above is not portable - an output file produced on one architecture may not be interpreted properly when read on another. To correct this, the endianness of serialized data must be defined - this library provides the mutator types <code>little_endian</code> and <code>big_endian</code> for this purpose.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike Boost.Serializable, which embeds endianness information into the stream (or Archive), this library specifies endianness of individual values. This is largely a reflection of the different intended use cases of the two libraries - there is no guarantee that a protocol will use consistent byte (or bit) packing across any logical message block. Applications may recover this behaviour, if desirable, using custom container types or by redefining the default serialization of fundamental types, provided in <code><a class="el" href="base__types_8hpp.html" title="Fundamental serializable definitions.">base_types.hpp</a></code>.</dd></dl>
<p>This library distinguishes between various types of constructs in a specification - containers types and value types, for example, operate on serializable objects, while mutators types operate directly on underlying data. A mutator type can be thought of as "wrapping" the serialization of an underlying type (ie: another mutator, a string, a vector, a tuple, a fundamental type, ...), defining or altering how that type is serialized. Mutator types generally use the following basic pattern:</p>
<div class="fragment"><div class="line"><span class="comment">// mutator_type &lt;internal_type(s), underlying_type&gt;</span></div>
<div class="line">mutator_type &lt;int&gt;</div>
<div class="line">mutator_type &lt;mutator_type &lt;int&gt;&gt;</div>
<div class="line">mutator_type &lt;int, std::vector &lt;int&gt;&gt;</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Some of the mutators defined by this library restrict the underlying type; <code>little_endian</code> and <code>big_endian</code>, for example, require an underlying fundamental type.</dd></dl>
<p>A simple portable example using the <code>little_endian</code> and <code>big_endian</code> mutators to serialize data is provided in <code>a_portable_example.cpp:</code> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serializable_8hpp.html" title="Common serializable includes.">framework/serializable.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stl__string_8hpp.html" title="Common STL string aliases.">framework/serializable/mutators/stl_string.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="namespaceframework_1_1serializable.html#a0f51cdf6a41c7cc40fbe951b0da49823" title="Common STL wstring specification.">using ::framework::serializable::stl_wstring</a>;</div>
<div class="line">using ::framework::serializable::little_endian;</div>
<div class="line">using ::framework::serializable::big_endian;</div>
<div class="line">using ::framework::serializable::value;</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> <span class="keywordtype">object</span> = <a class="code" href="exceptionframework_1_1serializable_1_1inline__object.html" title="Inline object wrapper.">::framework::serializable::inline_object</a> &lt;</div>
<div class="line">    value &lt;NAME(<span class="stringliteral">&quot;Field 1&quot;</span>), little_endian &lt;int32_t&gt;&gt;,</div>
<div class="line">    value &lt;NAME(<span class="stringliteral">&quot;Field 2&quot;</span>), big_endian &lt;double&gt;&gt;,</div>
<div class="line">    value &lt;NAME(<span class="stringliteral">&quot;Field 3&quot;</span>), stl_wstring &lt;little_endian &lt;uint32_t&gt;&gt;&gt;&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create an object</span></div>
<div class="line">    <span class="keywordtype">object</span> o1 {1, 2.0, L<span class="stringliteral">&quot;Hello World!&quot;</span>};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Write the object to a file</span></div>
<div class="line">    assert(<a class="code" href="namespaceframework_1_1serializable.html#a99b0af2f2f45ba69a1d6b7c7fc2dbb5e" title="Write forwarder.">write</a>(o1, std::ofstream(<span class="stringliteral">&quot;filename&quot;</span>)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read the object from a file</span></div>
<div class="line">    <span class="keywordtype">object</span> o2;</div>
<div class="line">    assert(<a class="code" href="namespaceframework_1_1serializable.html#a116938beb8e2e5e17ac3029a7b5c2e60" title="Read fowarder.">read</a>(std::ifstream(<span class="stringliteral">&quot;filename&quot;</span>), o2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check the value</span></div>
<div class="line">    assert(o1 == o2);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>"filename" output:</p>
<div class="fragment"><div class="line">0000000: 0100 0000 4000 0000 0000 0000 0c00 0000  ....@...........</div>
<div class="line">0000010: 4800 0000 6500 0000 6c00 0000 6c00 0000  H...e...l...l...</div>
<div class="line">0000020: 6f00 0000 2000 0000 5700 0000 6f00 0000  o... ...W...o...</div>
<div class="line">0000030: 7200 0000 6c00 0000 6400 0000 2100 0000  r...l...d...!...</div>
</div><!-- fragment --><h1><a class="anchor" id="serializable_custom_structures"></a>
Custom structures</h1>
<p>The preceding examples used <code>inline_object</code> to define the layout of a structure. This template is convenient for it's brevity - constructors, comparison operators, and common accessor methods are all defined. User defined structures may want to include some or all of these features - to illustrate how this performed in this library, the construction of a comparable structure is covered in some detail here.</p>
<p>To begin, we present a simple C structure we would like to transform into a serializable object:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>object</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">double</span> y;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> foo () { <span class="keywordflow">return</span> x + y; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The structure above (neglecting foo for the moment) may be reformulated as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>object : <a class="code" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562" title="Implementation alias.">serializable</a> &lt;object,</div>
<div class="line">    value &lt;NAME(&quot;x&quot;), int&gt;,</div>
<div class="line">    value &lt;NAME(&quot;y&quot;), double&gt;&gt;</div>
<div class="line">{</div>
<div class="line">};</div>
</div><!-- fragment --><p>The above is sufficient to allow the serializable library to read/write <code>object</code>, interact with fields through the free functions defined in <a class="el" href="common_8hpp.html" title="Common accessors aliases.">common.hpp</a>, and compare the object through the free functions defined in <a class="el" href="comparable_8hpp.html" title="Serializable container comparison.">comparable.hpp</a>. For example, the following sets and compares two such objects:</p>
<div class="fragment"><div class="line"><span class="keywordtype">object</span> o1, o2;</div>
<div class="line"></div>
<div class="line"><span class="keyword">set</span> &lt;NAME(<span class="stringliteral">&quot;x&quot;</span>)&gt; (o1, 1);</div>
<div class="line"><span class="keyword">set</span> &lt;NAME(<span class="stringliteral">&quot;y&quot;</span>)&gt; (o1, 2.0);</div>
<div class="line"><span class="keyword">set</span> &lt;NAME(<span class="stringliteral">&quot;x&quot;</span>)&gt; (o2, 1);</div>
<div class="line"><span class="keyword">set</span> &lt;NAME(<span class="stringliteral">&quot;y&quot;</span>)&gt; (o2, 3.0);</div>
<div class="line"></div>
<div class="line">assert(less_than(o1, o2));</div>
</div><!-- fragment --><p>The above is clearly unwieldy - construction and comparison are needlessly verbose. To address this, we begin by adding a forwarding constructor:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>object : <a class="code" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562" title="Implementation alias.">serializable</a> &lt;object,</div>
<div class="line">    value &lt;NAME(&quot;x&quot;), int&gt;,</div>
<div class="line">    value &lt;NAME(&quot;y&quot;), double&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    object (Args&amp;&amp;... args)</div>
<div class="line">        : object::serializable_base(std::forward &lt;Args&gt; (args)...)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <code>serializable</code> base class here defines how the above arguments are mapped to the associated base class constructors. Generally speaking, one parameter in the above pack is forwarded to each named value in an object, in the order it appears in the object's specification.</dd>
<dd>
The <code>serializable_base</code> typedef is provided by <code>serializable</code> to allow <code>object</code> to easily refer to this base without duplicating the template parameters provided to <code>serializable</code>.</dd></dl>
<p>With the above constructor in place, we may reformulate the sample code above more efficiently as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">object</span> o1{1, 2.0}, o2{1, 3.0};</div>
<div class="line">assert(less_than(o1, o2));</div>
</div><!-- fragment --><p>Next, common comparison operators need to be added. The defaults (member-wise comparison) are sufficient here and as such these operators may be added trivially through the use of the <code>comparable</code> template:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>object : </div>
<div class="line">    comparable &lt;object&gt;,</div>
<div class="line">    <a class="code" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562" title="Implementation alias.">serializable</a> &lt;object,</div>
<div class="line">        value &lt;NAME(&quot;x&quot;), int&gt;,</div>
<div class="line">        value &lt;NAME(&quot;y&quot;), double&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    object (Args&amp;&amp;... args)</div>
<div class="line">        : object::serializable_base(std::forward &lt;Args&gt; (args)...)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The above provides <code>object</code> with common comparison operators through the use of the Barton-Nackman trick. This leads to the final reformulation of the above sample:</p>
<div class="fragment"><div class="line"><span class="keywordtype">object</span> o1{1, 2.0}, o2{1, 3.0};</div>
<div class="line">assert(o1 &lt; o2);</div>
</div><!-- fragment --><p>Finally, we return to the sample function <code>foo</code>. Objects similar to the above should generally access members of it's base classes directly rather than relying on free functions like <code>get</code> and <code>set</code> - this allows the class access to protected members of a value type's implementation. The <code>get_base</code> template facilitates this by providing a means of associating a value type's identifier with the corresponding base class type, as demonstrated below:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>object : </div>
<div class="line">    comparable &lt;object&gt;,</div>
<div class="line">    <a class="code" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562" title="Implementation alias.">serializable</a> &lt;object,</div>
<div class="line">        value &lt;NAME(&quot;x&quot;), int&gt;,</div>
<div class="line">        value &lt;NAME(&quot;y&quot;), double&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    object (Args&amp;&amp;... args)</div>
<div class="line">        : object::serializable_base(std::forward &lt;Args&gt; (args)...)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> foo ()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> x = <span class="keyword">typename</span> get_base &lt;object, NAME(<span class="stringliteral">&quot;x&quot;</span>)&gt;<a class="code" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3" title="Result.">::type</a>;</div>
<div class="line">        <span class="keyword">using</span> y = <span class="keyword">typename</span> get_base &lt;object, NAME(<span class="stringliteral">&quot;y&quot;</span>)&gt;<a class="code" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3" title="Result.">::type</a>;</div>
<div class="line">    </div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceframework_1_1serializable.html#a9e424c9a7e9c6032083bd6b28a1a18ca" title="Get.">x::get</a>() + <a class="code" href="namespaceframework_1_1serializable.html#a9e424c9a7e9c6032083bd6b28a1a18ca" title="Get.">y::get</a>();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Again, the syntax above is rather unwieldy - the basic pattern is clearly required to retain protected access, however we can clean up the retrieval of the base class somewhat. In particular, a template alias may be used to reduce most of the redundancy above - the macro <code>DEFINE_BASE_TEMPLATE</code> is provided for exactly that purpose. This change leads to the final reformulation of <code>object</code> as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>object : </div>
<div class="line">    comparable &lt;object&gt;,</div>
<div class="line">    <a class="code" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562" title="Implementation alias.">serializable</a> &lt;object,</div>
<div class="line">        value &lt;NAME(&quot;x&quot;), int&gt;,</div>
<div class="line">        value &lt;NAME(&quot;y&quot;), double&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    DEFINE_BASE_TEMPLATE(<span class="keywordtype">object</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    object (Args&amp;&amp;... args)</div>
<div class="line">        : object::serializable_base(std::forward &lt;Args&gt; (args)...)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> foo ()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> base &lt;NAME(<span class="stringliteral">&quot;x&quot;</span>)&gt;<a class="code" href="namespaceframework_1_1serializable.html#a9e424c9a7e9c6032083bd6b28a1a18ca" title="Get.">::get</a>() + base &lt;NAME(<span class="stringliteral">&quot;y&quot;</span>)&gt;<a class="code" href="namespaceframework_1_1serializable.html#a9e424c9a7e9c6032083bd6b28a1a18ca" title="Get.">::get</a>();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The above introduced nearly every convenience feature provided by <code>inline_object</code> with the exception of common accessor methods; their construction is neglected here. These methods introduce no new library specific information and as such the implementation of <code>inline_object</code> should suffice - see <code><a class="el" href="inline__object_8hpp.html" title="Inline object wrapper.">inline_object.hpp</a></code> for more details. A simple example of a custom structure definition, together with an appropriate serialization test, is provided in custom_structures.cpp:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serializable_8hpp.html" title="Common serializable includes.">framework/serializable.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stl__string_8hpp.html" title="Common STL string aliases.">framework/serializable/mutators/stl_string.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line">using ::framework::serializable::comparable;</div>
<div class="line"><a class="code" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562" title="Implementation alias.">using ::framework::serializable::serializable</a>;</div>
<div class="line">using ::framework::serializable::value;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>object :</div>
<div class="line">    comparable &lt;object&gt;,</div>
<div class="line">    <a class="code" href="namespaceframework_1_1serializable.html#af3a77276bf43db604807844d1cde1562" title="Implementation alias.">serializable</a> &lt;object,</div>
<div class="line">        value &lt;NAME(&quot;Field 1&quot;), int&gt;,</div>
<div class="line">        value &lt;NAME(&quot;Field 2&quot;), double&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    object (Args&amp;&amp;... args)</div>
<div class="line">        : object::serializable_base(std::forward &lt;Args&gt; (args)...)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Defines a convenient &#39;base&#39; alias for get_base</span></div>
<div class="line">    DEFINE_BASE_TEMPLATE(<span class="keywordtype">object</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Example method</span></div>
<div class="line">    <span class="keywordtype">void</span> foo ()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> x1 = base &lt;NAME(<span class="stringliteral">&quot;Field 1&quot;</span>)&gt;;</div>
<div class="line">        <span class="keyword">using</span> x2 = base &lt;NAME(<span class="stringliteral">&quot;Field 2&quot;</span>)&gt;;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespaceframework_1_1serializable.html#a9e424c9a7e9c6032083bd6b28a1a18ca" title="Get.">x1::get</a>() &gt; 0)</div>
<div class="line">            <a class="code" href="namespaceframework_1_1serializable.html#a739eef06f5db7c8ed56fdcdaa25bed82" title="Set.">x2::set</a>(<a class="code" href="namespaceframework_1_1serializable.html#a9e424c9a7e9c6032083bd6b28a1a18ca" title="Get.">x2::get</a>() + 1.0);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            <a class="code" href="namespaceframework_1_1serializable.html#a739eef06f5db7c8ed56fdcdaa25bed82" title="Set.">x2::set</a>(<a class="code" href="namespaceframework_1_1serializable.html#a9e424c9a7e9c6032083bd6b28a1a18ca" title="Get.">x2::get</a>() - 1.0);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create an object</span></div>
<div class="line">    <span class="keywordtype">object</span> o1 {1, 2.0};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Write the object to a file</span></div>
<div class="line">    assert(<a class="code" href="namespaceframework_1_1serializable.html#a99b0af2f2f45ba69a1d6b7c7fc2dbb5e" title="Write forwarder.">write</a>(o1, std::ofstream(<span class="stringliteral">&quot;filename&quot;</span>)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read the object from a file</span></div>
<div class="line">    <span class="keywordtype">object</span> o2;</div>
<div class="line">    assert(<a class="code" href="namespaceframework_1_1serializable.html#a116938beb8e2e5e17ac3029a7b5c2e60" title="Read fowarder.">read</a>(std::ifstream(<span class="stringliteral">&quot;filename&quot;</span>), o2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check the value</span></div>
<div class="line">    assert(o1 == o2);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="serializable_custom_implementation"></a>
Custom implementations</h1>
<p>Value types provided in this library allow a final optional template parameter that may be used to override the type's default implementation. This may be desirable for numerous reasons - direct access to the underlying type may be required, accessors may need to be protected, invariants may need to be established, and so on. The examples provided in custom_implementation.cpp illustrate the usage of this parameter by providing two such implementations - the first establishes a simple invariant while the second widens an arbitrary underlying value type to an integer, where appropriate.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation override used here accepts a single typename parameter used to provide the structure with the information it may require from the value type's specification. For example, <code>value</code> provides it's implementation with the associated name, underlying type, derived class type, and so on - see value_implementation_wrapper for more details. Custom implementations are strongly encouraged to use these types to avoid effective duplication of portions of the object's specification.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serializable_8hpp.html" title="Common serializable includes.">framework/serializable.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stl__string_8hpp.html" title="Common STL string aliases.">framework/serializable/mutators/stl_string.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>object_impl</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span>version</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">typename</span> T::value_type <span class="keyword">get</span> () <span class="keyword">const</span></div>
<div class="line">        { </div>
<div class="line">            <span class="keywordflow">return</span> 5; </div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> <span class="keyword">set</span> (<span class="keyword">typename</span> T::value_type <span class="keyword">const</span>&amp; x) <span class="keyword">const</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (x != 5)</div>
<div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Invalid object: Version not supported&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">protected</span>:</div>
<div class="line">            ~version () = <span class="keywordflow">default</span>;</div>
<div class="line">            version () = <span class="keywordflow">default</span>;</div>
<div class="line"></div>
<div class="line">            version (<span class="keyword">typename</span> T::value_type <span class="keyword">const</span>&amp; x)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (x != 5)</div>
<div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Invalid object: Version not supported&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>widen_value</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">enum</span> { widen = std::is_arithmetic &lt;typename T::value_type&gt;::value &amp;&amp; <span class="keyword">sizeof</span>(<span class="keyword">typename</span> T::value_type) &lt;= <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">typename</span> std::conditional &lt;</div>
<div class="line">            widen,</div>
<div class="line">            int,</div>
<div class="line">            <span class="keyword">typename</span> T::value_type</div>
<div class="line">        &gt;<a class="code" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3" title="Result.">::type</a> p_tValue;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typename</span> std::conditional &lt;</div>
<div class="line">            widen,</div>
<div class="line">            <span class="keyword">typename</span> T::value_type,</div>
<div class="line">            <span class="keyword">typename</span> T::value_type <span class="keyword">const</span>&amp;</div>
<div class="line">        &gt;<a class="code" href="namespaceframework.html#aa5b5a07dab11ce10af8a7f9a27baf2f3" title="Result.">::type</a> <span class="keyword">get</span> () <span class="keyword">const</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> p_tValue;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> <span class="keyword">set</span> (<span class="keyword">typename</span> T::value_type x)</div>
<div class="line">        {</div>
<div class="line">            p_tValue = std::move(x);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        ~widen_value () = <span class="keywordflow">default</span>;</div>
<div class="line">        widen_value () = <span class="keywordflow">default</span>;</div>
<div class="line">    </div>
<div class="line">        widen_value (<span class="keyword">typename</span> T::value_type x)</div>
<div class="line">            : p_tValue(std::move(x))</div>
<div class="line">        {</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// An in-place constructor could be provided here; omitted for brevity.</span></div>
<div class="line">        <span class="comment">// See value_implementation for an example of this.</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">using ::framework::serializable::inline_object;</div>
<div class="line">using ::framework::serializable::value;</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> <span class="keywordtype">object</span> = inline_object &lt;</div>
<div class="line">    value &lt;NAME(<span class="stringliteral">&quot;Version&quot;</span>), uint8_t, object_impl::version&gt;,</div>
<div class="line">    value &lt;NAME(<span class="stringliteral">&quot;Value&quot;</span>), short, widen_value&gt;&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create an object</span></div>
<div class="line">    <span class="keywordtype">object</span> o1 {5, 2.0};</div>
<div class="line"></div>
<div class="line">    o1.get &lt;NAME(<span class="stringliteral">&quot;Value&quot;</span>)&gt; ();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Write the object to a file</span></div>
<div class="line">    assert(<a class="code" href="namespaceframework_1_1serializable.html#a99b0af2f2f45ba69a1d6b7c7fc2dbb5e" title="Write forwarder.">write</a>(o1, std::ofstream(<span class="stringliteral">&quot;filename&quot;</span>)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Read the object from a file</span></div>
<div class="line">    <span class="keywordtype">object</span> o2;</div>
<div class="line">    assert(<a class="code" href="namespaceframework_1_1serializable.html#a116938beb8e2e5e17ac3029a7b5c2e60" title="Read fowarder.">read</a>(std::ifstream(<span class="stringliteral">&quot;filename&quot;</span>), o2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check the value</span></div>
<div class="line">    <span class="comment">//assert(o1 == o2);</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Original bool size: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(inline_object &lt;value &lt;NAME(<span class="stringliteral">&quot;x&quot;</span>), <span class="keywordtype">bool</span>&gt;&gt;) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Widened bool size: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(inline_object &lt;value &lt;NAME(<span class="stringliteral">&quot;x&quot;</span>), bool, widen_value&gt;&gt;) &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd><ul>
<li>Introduce the differences between container types, value types, and mutator</li>
<li>Add documentation for "custom_serialization" example</li>
<li>Add documentation for "adding_mutator_types" example</li>
<li>Add documentation for "adding_container_types" example</li>
<li>Add documentation for "custom_serializable_implementation" example </li>
</ul>
</dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 24 2012 10:32:07 for framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2-20121118
</small></address>
</body>
</html>
