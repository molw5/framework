/**
* \page serializable_intro Introduction
* ### Primary design goals: ###
*  1. Arbitrary protocol specification
*  2. No separation of specification information
*  3. No duplication of specification information
* 
* ### Secondary design goals: ###
*  4. Portability - code must compile on any C++11 compliant compiler; 
*     platform/library specific code must provide alternatives
*  5. Code economy - trivial methods (operators, constructors, print 
*     methods, ...) should not require object-specific implementations
*  6. Code efficiency - it should be possible to override the default 
*     behaviour of arbitrarily specific combinations of operators
*  7. Zero overhead - the abstractions used here should introduce no 
*     intrinsic overhead over an equivalent operation on a raw C structure
* 
* ### Existing implementations: ###
*  - Boost.Serialization - fails primary goals 2 and 3, arguably fails 1
*  - Google Protocol Buffers - fails primary goal 1
**/

/**
* \page serializable_license License
*
* This project is distributed under the MIT License, as specified in \c COPYING
*
* \verbinclude COPYING
*/

/**
* \page serializable_requirements Requirements
* \note
* This library leverages new C++11 language features heavily - as such, no
* attempt has been made to maintain compatibility with older compilers.
* Certain features critical to the implementation of the syntax used here,
* such as the \c NAME macro, have no comparable C++03 or common vendor
* specific equivalents.
* 
* ### Required C++11 Features: ###
* - Rvalue references
* - Variadic templates
* - Static assertions
* - auto-typed variables
*  - New function declarator syntax
* - Declared type of an expression
* - Right angle brackets
* - Template aliases
* - Null pointer constant
* - Generalized constant expressions
* - Delegating constructors
* - Defaulted and deleted functions
* - Extended friend declarations
* - Range-based for
* 
* \warning
* The list above may be incomplete or dated.
* 
* ### Supported compilers: ###
*  - GCC 4.7.2
*  - clang 3.3
**/

/**
* \page serializable_tutorial Tutorial
* \tableofcontents
*
* \section serializable_simple A simple example
* 
* The code provided in \c a_simple_example.cpp demonstrates the simplest 
* possible use case for this library - a basic structure is defined, 
* serialized, and deserialized.
* 
* \include a_simple_example.cpp
* 
* "filename" output:
* 
* \code
* 0000000: 0100 0000 0000 0000 0000 0040 4865 6c6c  ...........@Hell
* 0000010: 6f20 576f 726c 6421 00                   o World!.
* \endcode
*
* \section serializable_portable A portable example
*
* The example above is not portable - an output file produced on one 
* architecture may not be interpreted properly when read on another.
* To correct this, the endianness of serialized data must
* be defined - this library provides the mutator types \c little_endian
* and \c big_endian for this purpose.
*
* \note
* Unlike Boost.Serializable, which embeds endianness information into the 
* stream (or Archive), this library specifies endianness of individual
* values.  This is largely a reflection of the different intended use
* cases of the two libraries - there is no guarantee that a protocol
* will use consistent byte (or bit) packing across any logical message
* block.  Applications may recover this behaviour, if desirable, using
* custom container types or by redefining the default serialization of
* fundamental types, provided in \c base_types.hpp.
*
* This library distinguishes between various types of constructs in a specification -  containers types 
* and value types, for example, operate on serializable objects, while mutators types operate 
* directly on underlying data.  A mutator type can be thought of as "wrapping" the serialization of an
* underlying type (ie: another mutator, a string, a vector, a tuple, a fundamental type, ...), defining 
* or altering how that type is serialized.  Mutator types generally use the following basic pattern:
*
* \code
* // mutator_type <internal_type(s), underlying_type>
* mutator_type <int>
* mutator_type <mutator_type <int>>
* mutator_type <int, std::vector <int>>
* ...
* \endcode
*
* \note
* Some of the mutators defined by this library restrict the underlying
* type; \c little_endian and \c big_endian, for example, require an underlying
* fundamental type.
*
* A simple portable example using the \c little_endian and \c big_endian mutators
* to serialize data is provided in \c a_portable_example.cpp:
* 
* \include a_portable_example.cpp
* 
* "filename" output:
* 
* \code
* 0000000: 0100 0000 4000 0000 0000 0000 0c00 0000  ....@...........
* 0000010: 4800 0000 6500 0000 6c00 0000 6c00 0000  H...e...l...l...
* 0000020: 6f00 0000 2000 0000 5700 0000 6f00 0000  o... ...W...o...
* 0000030: 7200 0000 6c00 0000 6400 0000 2100 0000  r...l...d...!...
* \endcode
*
* \section serializable_custom_structures Custom structures
*
* The preceding examples used \c inline_object to define the layout of a structure.  This template is 
* convenient for it's brevity - constructors, comparison operators, and common accessor methods are all 
* defined.  User defined structures may want to include some or all of these features - to illustrate
* how this performed in this library, the construction of a comparable structure is covered in some
* detail here.
*
* To begin, we present a simple C structure we would like to transform into a serializable object:
*
* \code
* struct object
* {
*     int x;
*     double y;
*
*     double foo () { return x + y; }
* };
* \endcode
*
* The structure above (neglecting foo for the moment) may be reformulated as follows:
*
* \code
struct object : serializable <object,
    value <NAME("x"), int>,
    value <NAME("y"), double>>
{
};
* \endcode
*
* The above is sufficient to allow the serializable library to read/write \c object, interact with fields 
* through the free functions defined in common.hpp, and compare the object through the free functions 
* defined in comparable.hpp.  For example, the following sets and compares two such objects:
* 
* \code
* object o1, o2;
* 
* set <NAME("x")> (o1, 1);
* set <NAME("y")> (o1, 2.0);
* set <NAME("x")> (o2, 1);
* set <NAME("y")> (o2, 3.0);
* 
* assert(less_than(o1, o2));
* \endcode
* 
* The above is clearly unwieldy - construction and comparison are needlessly verbose.  To address this, we 
* begin by adding a forwarding constructor:
* 
* \code
* struct object : serializable <object,
*     value <NAME("x"), int>,
*     value <NAME("y"), double>>
* {
*     template <typename... Args>
*     object (Args&&... args)
*         : object::serializable_base(std::forward <Args> (args)...)
*     {
*     }
* };
* \endcode
*
* \note
* The \c serializable base class here defines how the above arguments are mapped to the associated base 
* class constructors.  Generally speaking, one parameter in the above pack is forwarded to each named 
* value in an object, in the order it appears in the object's specification.
*
* \note
* The \c serializable_base typedef is provided by \c serializable to allow \c object to easily refer
* to this base without duplicating the template parameters provided to \c serializable.
* 
* With the above constructor in place, we may reformulate the sample code above more efficiently as:
* 
* \code
* object o1{1, 2.0}, o2{1, 3.0};
* assert(less_than(o1, o2));
* \endcode
* 
* Next, common comparison operators need to be added.  The defaults (member-wise comparison) are sufficient
* here and as such these operators may be added trivially through the use of the \c comparable template:
*
* \code
* struct object : 
*     comparable <object>,
*     serializable <object,
*         value <NAME("x"), int>,
*         value <NAME("y"), double>>
* {
*     template <typename... Args>
*     object (Args&&... args)
*         : object::serializable_base(std::forward <Args> (args)...)
*     {
*     }
* };
* \endcode
* 
* The above provides \c object with common comparison operators through the use of the Barton-Nackman
* trick.  This leads to the final reformulation of the above sample:
* 
* \code
* object o1{1, 2.0}, o2{1, 3.0};
* assert(o1 < o2);
* \endcode
* 
* Finally, we return to the sample function \c foo.  Objects similar to the above should generally
* access members of it's base classes directly rather than relying on free functions like \c get 
* and \c set - this allows the class access to protected members of a value type's implementation.
* The \c get_base template facilitates this by providing a means of associating a value type's
* identifier with the corresponding base class type, as demonstrated below:
*
* \code
* struct object : 
*     comparable <object>,
*     serializable <object,
*         value <NAME("x"), int>,
*         value <NAME("y"), double>>
* {
*     template <typename... Args>
*     object (Args&&... args)
*         : object::serializable_base(std::forward <Args> (args)...)
*     {
*     }
*
*     double foo ()
*     {
*         using x = typename get_base <object, NAME("x")>::type;
*         using y = typename get_base <object, NAME("y")>::type;
*     
*         return x::get() + y::get();
*     }
* };
* \endcode
*
* Again, the syntax above is rather unwieldy - the basic pattern is clearly required to
* retain protected access, however we can clean up the retrieval of the base class somewhat.
* In particular, a template alias may be used to reduce most of the redundancy above - the
* macro \c DEFINE_BASE_TEMPLATE is provided for exactly that purpose.  This change leads to
* the final reformulation of \c object as follows:
*
* \code
* struct object : 
*     comparable <object>,
*     serializable <object,
*         value <NAME("x"), int>,
*         value <NAME("y"), double>>
* {
*     DEFINE_BASE_TEMPLATE(object);
*
*     template <typename... Args>
*     object (Args&&... args)
*         : object::serializable_base(std::forward <Args> (args)...)
*     {
*     }
*
*     double foo ()
*     {
*         return base <NAME("x")>::get() + base <NAME("y")>::get();
*     }
* };
* \endcode
*
* The above introduced nearly every convenience feature provided by \c inline_object with the 
* exception of common accessor methods; their construction is neglected here.  These methods 
* introduce no new library specific information and as such the implementation of 
* \c inline_object should suffice - see \c inline_object.hpp for more details. A simple example of 
* a custom structure definition, together with an appropriate serialization test, is provided 
* in custom_structures.cpp:
* 
* \include custom_structures.cpp
*
* \section serializable_custom_implementation Custom implementations
*
* Value types provided in this library allow a final optional template parameter that may be used
* to override the type's default implementation.  This may be desirable for numerous reasons -
* direct access to the underlying type may be required, accessors may need to be protected,
* invariants may need to be established, and so on.  The examples provided in custom_implementation.cpp
* illustrate the usage of this parameter by providing two such implementations - the first establishes
* a simple invariant while the second widens an arbitrary underlying value type to an integer, where
* appropriate.
*
* \note
* The implementation override used here accepts a single typename parameter used to provide the
* structure with the information it may require from the value type's specification.  For example,
* \c value provides it's implementation with the associated name, underlying type, derived class type,
* and so on - see value_implementation_wrapper for more details.  Custom implementations are
* strongly encouraged to use these types to avoid effective duplication of portions of the object's
* specification.
* 
* \include custom_implementation.cpp
*
* \todo
* - Introduce the differences between container types, value types, and mutator 
* - Add documentation for "custom_serialization" example
* - Add documentation for "adding_mutator_types" example
* - Add documentation for "adding_container_types" example
* - Add documentation for "custom_serializable_implementation" example
*/ 

/**
* \page serializable_discussion Discussion
* \tableofcontents
*
* \section serializable_zero_overhead Zero overhead
*
* One of the design goals of this library was to keep the implementation
* as close to zero-overhead as possible.  As such, it is worth examining how well this library achieves 
* this goal.  To begin, we will examine the overhead associated with 
* variable access relative to that of a simple C structure.  The following 
* test code was used to isolate these operations to individual functions 
* using GCC's noinline attribute:
*
* \include access_overhead.cpp
*
* Compiling the above using the following invocation of g++:
*
* \code
* g++ -std=c++11 -I./ -O2 ./examples/serializable/access_overhead.cpp
* \endcode
*
* produces the following assembly, organized into test pairs:
*
* \code
* 00000000004008b0 <int access_control<s1>(s1&)>:
* 4008b0: 8b 07                   mov    (%rdi),%eax
* 4008b2: c3                      retq   
* 4008b3: 66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
* 4008ba: 00 00 00 
* 4008bd: 0f 1f 00                nopl   (%rax)
* 
* 00000000004008c0 <int access_test<framework: :serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > >(framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> >&)>:
* 4008c0: 8b 07                   mov    (%rdi),%eax
* 4008c2: c3                      retq   
* 4008c3: 66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
* 4008ca: 00 00 00 
* 4008cd: 0f 1f 00                nopl   (%rax)
* 
* 00000000004008d0 <void assignment_control<s1>(s1&)>: 
* 4008d0: c7 07 01 00 00 00       movl   $0x1,(%rdi)
* 4008d6: c3                      retq   
* 4008d7: 66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
* 4008de: 00 00 
* 
* 00000000004008e0 <void assignment_test<framework: :serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > >(framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> >&)>:
* 4008e0: c7 07 01 00 00 00       movl   $0x1,(%rdi)
* 4008e6: c3                      retq   
* 4008e7: 66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
* 4008ee: 00 00 
* 
* 00000000004008f0 <void construction_control<s1>(s1&)>: 
* 4008f0: c7 07 d2 04 00 00       movl   $0x4d2,(%rdi)
* 4008f6: c3                      retq   
* 4008f7: 66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
* 4008fe: 00 00 
* 
* 0000000000400900 <void construction_test<framework: :serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > >(framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> >&)>:
* 400900: c7 07 d2 04 00 00       movl   $0x4d2,(%rdi)
* 400906: c3                      retq   
* 400907: 66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
* 40090e: 00 00
* \endcode
*
* Note that in each test above produces identical control and test methods.
* The results above are hardly exhaustive, however it appears that in the
* very simple cases presented above GCC's was able to completely optimize
* out the abstraction achieving the secondary 'zero-overhead' design goal.
*
* Next, we'll examine serialization operations.  Here, a call to \c read 
* or \c write invokes a series of trivial inline tagged read/write methods 
* defined by the object's type.  As such, the compiler's optimizer is expected
* to be capable of producing code equivalent to invoking the underlying stream's
* read/write functions directly on a raw C structure.  Again, examining only
* the simplest possible test case here:
* 
* \include serialization_overhead.cpp
*
* and compiling using the same invocation of g++:
*
* \code
* g++ -std=c++11 -I./ -O2 ./examples/serializable/access_overhead.cpp
* \endcode
*
* produces the following assembly, organized into test pairs:
*
* \code
* 0000000000400aa0 <bool write_control<s1, std: :basic_stringstream<char, std::char_traits<char>, std::allocator<char> > >(s1 const&, std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >&)>:
* 400aa0: 48 89 f8                mov    %rdi,%rax
* 400aa3: 48 8d 7e 10             lea    0x10(%rsi),%rdi
* 400aa7: 48 83 ec 08             sub    $0x8,%rsp
* 400aab: ba 04 00 00 00          mov    $0x4,%edx
* 400ab0: 48 89 c6                mov    %rax,%rsi
* 400ab3: e8 88 fd ff ff          callq  400840 <std::ostream::write(char const*, long)@plt>
* 400ab8: 48 8b 10                mov    (%rax),%rdx
* 400abb: 48 8b 52 e8             mov    -0x18(%rdx),%rdx
* 400abf: f6 44 10 20 05          testb  $0x5,0x20(%rax,%rdx,1)
* 400ac4: 0f 94 c0                sete   %al
* 400ac7: 48 83 c4 08             add    $0x8,%rsp
* 400acb: c3                      retq   
* 400acc: 0f 1f 40 00             nopl   0x0(%rax)
* 
* 0000000000400ad0 <bool write_test<framework: :serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> >, std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> > >(framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > const&, std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >&)>:
* 400ad0: 48 89 f8                mov    %rdi,%rax
* 400ad3: 48 8d 7e 10             lea    0x10(%rsi),%rdi
* 400ad7: 48 83 ec 08             sub    $0x8,%rsp
* 400adb: ba 04 00 00 00          mov    $0x4,%edx
* 400ae0: 48 89 c6                mov    %rax,%rsi
* 400ae3: e8 58 fd ff ff          callq  400840 <std::ostream::write(char const*, long)@plt>
* 400ae8: 48 8b 10                mov    (%rax),%rdx
* 400aeb: 48 8b 52 e8             mov    -0x18(%rdx),%rdx
* 400aef: f6 44 10 20 05          testb  $0x5,0x20(%rax,%rdx,1)
* 400af4: 0f 94 c0                sete   %al
* 400af7: 48 83 c4 08             add    $0x8,%rsp
* 400afb: c3                      retq   
* 400afc: 0f 1f 40 00             nopl   0x0(%rax)
* 
* 0000000000400b00 <bool read_control<std: :basic_stringstream<char, std::char_traits<char>, std::allocator<char> >, s1>(std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >&, s1&)>:
* 400b00: 53                      push   %rbx
* 400b01: ba 04 00 00 00          mov    $0x4,%edx
* 400b06: 48 89 f3                mov    %rsi,%rbx
* 400b09: 48 83 ec 10             sub    $0x10,%rsp
* 400b0d: 48 89 e6                mov    %rsp,%rsi
* 400b10: e8 0b fd ff ff          callq  400820 <std::istream::read(char*, long)@plt>
* 400b15: 48 89 c2                mov    %rax,%rdx
* 400b18: 48 8b 00                mov    (%rax),%rax
* 400b1b: 48 8b 48 e8             mov    -0x18(%rax),%rcx
* 400b1f: 31 c0                   xor    %eax,%eax
* 400b21: f6 44 0a 20 05          testb  $0x5,0x20(%rdx,%rcx,1)
* 400b26: 75 0a                   jne    400b32 <bool read_control<std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >, s1>(std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >&, s1&)+0x32>
* 400b28: 8b 04 24                mov    (%rsp),%eax
* 400b2b: 89 03                   mov    %eax,(%rbx)
* 400b2d: b8 01 00 00 00          mov    $0x1,%eax
* 400b32: 48 83 c4 10             add    $0x10,%rsp
* 400b36: 5b                      pop    %rbx
* 400b37: c3                      retq   
* 400b38: 0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
* 400b3f: 00 
* 
* 0000000000400b40 <bool read_test<std: :basic_stringstream<char, std::char_traits<char>, std::allocator<char> >, framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > >(std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >&, framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> >&)>:
* 400b40: 53                      push   %rbx
* 400b41: 48 89 f3                mov    %rsi,%rbx
* 400b44: ba 04 00 00 00          mov    $0x4,%edx
* 400b49: 48 83 ec 10             sub    $0x10,%rsp
* 400b4d: 48 8d 74 24 0c          lea    0xc(%rsp),%rsi
* 400b52: e8 c9 fc ff ff          callq  400820 <std::istream::read(char*, long)@plt>
* 400b57: 48 89 c2                mov    %rax,%rdx
* 400b5a: 48 8b 00                mov    (%rax),%rax
* 400b5d: 48 8b 48 e8             mov    -0x18(%rax),%rcx
* 400b61: 31 c0                   xor    %eax,%eax
* 400b63: f6 44 0a 20 05          testb  $0x5,0x20(%rdx,%rcx,1)
* 400b68: 75 0b                   jne    400b75 <bool read_test<std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >, framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > >(std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> >&, framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> >&)+0x35>
* 400b6a: 8b 44 24 0c             mov    0xc(%rsp),%eax
* 400b6e: 89 03                   mov    %eax,(%rbx)
* 400b70: b8 01 00 00 00          mov    $0x1,%eax
* 400b75: 48 83 c4 10             add    $0x10,%rsp
* 400b79: 5b                      pop    %rbx
* 400b7a: c3                      retq   
* 400b7b: 0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
* \endcode
*
* Once again, aside from trivial differences the assembly produced for 
* control and tests cases is identical; our zero overhead requirement
* is again satisfied.
*
* Finally, we examine the default comparison operators.  Given the results
* in the preceding test the results here are not particularly interesting.
* The compiler is again expected to be capable to inlining the comparison
* operators used here to produce code equivalent to a similar operation
* involving a raw C structure:
*
* \include comparison_overhead.cpp
*
* Again, compiling the above using the same invocation of g++:
*
* \code
* g++ -std=c++11 -I./ -O2 ./examples/serializable/access_overhead.cpp
* \endcode
*
* produces the following assembly, organized into test pairs:
*
* \code
00000000004007a0 <bool compare_control<s1>(s1 const&, s1 const&)>: 
4007a0: 8b 06                   mov    (%rsi),%eax
4007a2: 39 07                   cmp    %eax,(%rdi)
4007a4: 0f 9c c0                setl   %al
4007a7: c3                      retq   
4007a8: 0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
4007af: 00 

00000000004007b0 <bool compare_test<framework: :serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > >(framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > const&, framework::serializable::inline_object<framework::serializable::value<framework::type_string<(char)120>, int, framework::serializable::value_implementation> > const&)>:
4007b0: 8b 06                   mov    (%rsi),%eax
4007b2: 39 07                   cmp    %eax,(%rdi)
4007b4: 0f 9c c0                setl   %al
4007b7: c3                      retq   
4007b8: 0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
4007bf: 00
* \endcode
*
* That is, our zero-overhead requirement is again satisfied in the above
* test cases as expected.
*/
