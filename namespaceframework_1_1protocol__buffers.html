<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1-20130402"/>
<title>framework: framework::protocol_buffers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1-20130402 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceframework.html">framework</a></li><li class="navelem"><a class="el" href="namespaceframework_1_1protocol__buffers.html">protocol_buffers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">framework::protocol_buffers Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Protocol buffers namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1protocol__buffer__implementation__wrapper.html">protocol_buffer_implementation_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation wrapper.  <a href="structframework_1_1protocol__buffers_1_1protocol__buffer__implementation__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1field__tag.html">field_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field tag.  <a href="structframework_1_1protocol__buffers_1_1field__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1field__base.html">field_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common field type base.  <a href="structframework_1_1protocol__buffers_1_1field__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1field__matcher.html">field_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field matcher.  <a href="structframework_1_1protocol__buffers_1_1field__matcher.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1fixed__tag.html">fixed_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time tag definition.  <a href="structframework_1_1protocol__buffers_1_1fixed__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1raw__input__frame.html">raw_input_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input frame wrapper.  <a href="structframework_1_1protocol__buffers_1_1raw__input__frame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1raw__output__frame.html">raw_output_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output frame wrapper.  <a href="structframework_1_1protocol__buffers_1_1raw__output__frame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1protocol__buffers_1_1length__delimited__input__frame.html">length_delimited_input_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length delimited input frame wrapper.  <a href="classframework_1_1protocol__buffers_1_1length__delimited__input__frame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1protocol__buffers_1_1size__frame.html">size_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size frame.  <a href="classframework_1_1protocol__buffers_1_1size__frame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1protocol__buffers_1_1max__size__frame.html">max_size_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size frame.  <a href="classframework_1_1protocol__buffers_1_1max__size__frame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1default__optional__value.html">default_optional_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default optional implementation.  <a href="structframework_1_1protocol__buffers_1_1default__optional__value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional value type.  <a href="structframework_1_1protocol__buffers_1_1optional.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1protocol__buffers_1_1message.html">message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message type.  <a href="classframework_1_1protocol__buffers_1_1message.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classframework_1_1protocol__buffers_1_1group.html">group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group type.  <a href="classframework_1_1protocol__buffers_1_1group.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1default__repeated__value.html">default_repeated_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default repeated implementation.  <a href="structframework_1_1protocol__buffers_1_1default__repeated__value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1repeated.html">repeated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeated value type.  <a href="structframework_1_1protocol__buffers_1_1repeated.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1default__required__value.html">default_required_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default required implementation.  <a href="structframework_1_1protocol__buffers_1_1default__required__value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1required.html">required</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required field type.  <a href="structframework_1_1protocol__buffers_1_1required.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1varint.html">varint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1zig__zag.html">zig_zag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__base.html">wire_type_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic wire type definitions.  <a href="structframework_1_1protocol__buffers_1_1wire__type__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wire type wrapper.  <a href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structframework_1_1protocol__buffers_1_1length__delimited.html">length_delimited</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length delimited type.  <a href="structframework_1_1protocol__buffers_1_1length__delimited.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8d3f95b8e8ede16886aef346e2746919"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d3f95b8e8ede16886aef346e2746919"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d3f95b8e8ede16886aef346e2746919"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a8d3f95b8e8ede16886aef346e2746919">remove_reference_cv</a> = typename std::remove_cv&lt; typename std::remove_reference&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:a8d3f95b8e8ede16886aef346e2746919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove reference/cv. <br/></td></tr>
<tr class="separator:a8d3f95b8e8ede16886aef346e2746919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503a87259958b24c91cecc6e889ee6eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a503a87259958b24c91cecc6e889ee6eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a503a87259958b24c91cecc6e889ee6eb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a503a87259958b24c91cecc6e889ee6eb">is_field_type</a> = typename detail::is_field_type_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a503a87259958b24c91cecc6e889ee6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is field type. <br/></td></tr>
<tr class="separator:a503a87259958b24c91cecc6e889ee6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab067f0323b7607f00d5dda12f81f1cf8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab067f0323b7607f00d5dda12f81f1cf8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab067f0323b7607f00d5dda12f81f1cf8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ab067f0323b7607f00d5dda12f81f1cf8">is_required</a> = typename detail::is_required_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab067f0323b7607f00d5dda12f81f1cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is required. <br/></td></tr>
<tr class="separator:ab067f0323b7607f00d5dda12f81f1cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8747970356ec4cb8457ecfafba7c5c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8747970356ec4cb8457ecfafba7c5c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8747970356ec4cb8457ecfafba7c5c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ab8747970356ec4cb8457ecfafba7c5c1">is_optional</a> = typename detail::is_optional_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab8747970356ec4cb8457ecfafba7c5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is optional. <br/></td></tr>
<tr class="separator:ab8747970356ec4cb8457ecfafba7c5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903fbe94071c084badcd22e2e2daacd4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a903fbe94071c084badcd22e2e2daacd4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a903fbe94071c084badcd22e2e2daacd4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a903fbe94071c084badcd22e2e2daacd4">is_repeated</a> = typename detail::is_repeated_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a903fbe94071c084badcd22e2e2daacd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is repeated. <br/></td></tr>
<tr class="separator:a903fbe94071c084badcd22e2e2daacd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb69b1893c8526b5c7754c626a2f39f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4cb69b1893c8526b5c7754c626a2f39f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cb69b1893c8526b5c7754c626a2f39f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a4cb69b1893c8526b5c7754c626a2f39f">field_number</a> = typename detail::field_number_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a4cb69b1893c8526b5c7754c626a2f39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field number. <br/></td></tr>
<tr class="separator:a4cb69b1893c8526b5c7754c626a2f39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd321f232827ff2942558b8d07b349e8"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd321f232827ff2942558b8d07b349e8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd321f232827ff2942558b8d07b349e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#afd321f232827ff2942558b8d07b349e8">field_type</a> = typename detail::field_type_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:afd321f232827ff2942558b8d07b349e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field type. <br/></td></tr>
<tr class="separator:afd321f232827ff2942558b8d07b349e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78de9936076af2c5434c75883e1f941"><td class="memTemplParams" colspan="2">template&lt;typename Lhs , typename Rhs &gt; </td></tr>
<tr class="memitem:af78de9936076af2c5434c75883e1f941"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#af78de9936076af2c5434c75883e1f941">field_less_than</a> = <a class="el" href="namespaceframework.html#a563bad81e0dc0c7eea5ae1377152c08b">value_less_than</a>&lt; <a class="el" href="namespaceframework_1_1protocol__buffers.html#a4cb69b1893c8526b5c7754c626a2f39f">field_number</a>&lt; Lhs &gt;, <a class="el" href="namespaceframework_1_1protocol__buffers.html#a4cb69b1893c8526b5c7754c626a2f39f">field_number</a>&lt; Rhs &gt;&gt;</td></tr>
<tr class="memdesc:af78de9936076af2c5434c75883e1f941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field less than.  <a href="#af78de9936076af2c5434c75883e1f941">More...</a><br/></td></tr>
<tr class="separator:af78de9936076af2c5434c75883e1f941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc5464b1a92494afc107933c6ec07f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0bc5464b1a92494afc107933c6ec07f7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bc5464b1a92494afc107933c6ec07f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a0bc5464b1a92494afc107933c6ec07f7">is_wire_type</a> = typename detail::is_wire_type_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a0bc5464b1a92494afc107933c6ec07f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is wire type. <br/></td></tr>
<tr class="separator:a0bc5464b1a92494afc107933c6ec07f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce55ec137daa4abee511e57b290f086"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afce55ec137daa4abee511e57b290f086"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#afce55ec137daa4abee511e57b290f086">is_integer_type</a> = typename detail::is_integer_type_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:afce55ec137daa4abee511e57b290f086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is integer type.  <a href="#afce55ec137daa4abee511e57b290f086">More...</a><br/></td></tr>
<tr class="separator:afce55ec137daa4abee511e57b290f086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab912a4c7b4da5c6d4f789352608a3291"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab912a4c7b4da5c6d4f789352608a3291"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab912a4c7b4da5c6d4f789352608a3291"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ab912a4c7b4da5c6d4f789352608a3291">wire_type</a> = typename detail::wire_type_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab912a4c7b4da5c6d4f789352608a3291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wire type. <br/></td></tr>
<tr class="separator:ab912a4c7b4da5c6d4f789352608a3291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a189c8ea3ea27daa503eee28b4af79e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a189c8ea3ea27daa503eee28b4af79e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a189c8ea3ea27daa503eee28b4af79e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a5a189c8ea3ea27daa503eee28b4af79e">make_wire_type</a> = typename detail::make_wire_type_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a5a189c8ea3ea27daa503eee28b4af79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make wire type. <br/></td></tr>
<tr class="separator:a5a189c8ea3ea27daa503eee28b4af79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78473aeceee202d4723886f581bb4423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78473aeceee202d4723886f581bb4423"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a78473aeceee202d4723886f581bb4423">float_</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::fixed_32, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">serializable::little_endian</a>&lt; float &gt;&gt;</td></tr>
<tr class="memdesc:a78473aeceee202d4723886f581bb4423"><td class="mdescLeft">&#160;</td><td class="mdescRight">float primitive. <br/></td></tr>
<tr class="separator:a78473aeceee202d4723886f581bb4423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1183af4123d29276795b11197a986e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f1183af4123d29276795b11197a986e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a6f1183af4123d29276795b11197a986e">double_</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::fixed_64, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">serializable::little_endian</a>&lt; double &gt;&gt;</td></tr>
<tr class="memdesc:a6f1183af4123d29276795b11197a986e"><td class="mdescLeft">&#160;</td><td class="mdescRight">double primitive. <br/></td></tr>
<tr class="separator:a6f1183af4123d29276795b11197a986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb16550c21cef0123ee9cb9b5bb2250"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdb16550c21cef0123ee9cb9b5bb2250"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#acdb16550c21cef0123ee9cb9b5bb2250">bool_</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::varint, <a class="el" href="structframework_1_1protocol__buffers_1_1varint.html">varint</a>&lt; bool &gt;&gt;</td></tr>
<tr class="memdesc:acdb16550c21cef0123ee9cb9b5bb2250"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool primitive. <br/></td></tr>
<tr class="separator:acdb16550c21cef0123ee9cb9b5bb2250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca202bff9b8797bf1bf254d1c663e95d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca202bff9b8797bf1bf254d1c663e95d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#aca202bff9b8797bf1bf254d1c663e95d">string_</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::length_delimited, <a class="el" href="namespaceframework_1_1serializable.html#a28d395d731b8146459ae379c56637ba9">serializable::stl_string</a>&lt; <a class="el" href="structframework_1_1protocol__buffers_1_1varint.html">varint</a>&lt; std::size_t &gt;&gt;&gt;</td></tr>
<tr class="memdesc:aca202bff9b8797bf1bf254d1c663e95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">string primitive. <br/></td></tr>
<tr class="separator:aca202bff9b8797bf1bf254d1c663e95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647af537e2201ba70b7b9441c55cb872"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a647af537e2201ba70b7b9441c55cb872"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a647af537e2201ba70b7b9441c55cb872">bytes</a> = <a class="el" href="namespaceframework_1_1protocol__buffers.html#aca202bff9b8797bf1bf254d1c663e95d">string_</a></td></tr>
<tr class="memdesc:a647af537e2201ba70b7b9441c55cb872"><td class="mdescLeft">&#160;</td><td class="mdescRight">bytes primitive. <br/></td></tr>
<tr class="separator:a647af537e2201ba70b7b9441c55cb872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cd2198965c7a1c4993ae2dccfce6b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5cd2198965c7a1c4993ae2dccfce6b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ac5cd2198965c7a1c4993ae2dccfce6b9">int32</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::varint, <a class="el" href="structframework_1_1protocol__buffers_1_1varint.html">varint</a>&lt; int32_t &gt;&gt;</td></tr>
<tr class="memdesc:ac5cd2198965c7a1c4993ae2dccfce6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">int32 primitive. <br/></td></tr>
<tr class="separator:ac5cd2198965c7a1c4993ae2dccfce6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb14c32214099cbc1bcb31e27786dc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bb14c32214099cbc1bcb31e27786dc3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a4bb14c32214099cbc1bcb31e27786dc3">int64</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::varint, <a class="el" href="structframework_1_1protocol__buffers_1_1varint.html">varint</a>&lt; int64_t &gt;&gt;</td></tr>
<tr class="memdesc:a4bb14c32214099cbc1bcb31e27786dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">int64 primitive. <br/></td></tr>
<tr class="separator:a4bb14c32214099cbc1bcb31e27786dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34dbe499be2b9b09d42f19eef4927ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac34dbe499be2b9b09d42f19eef4927ce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ac34dbe499be2b9b09d42f19eef4927ce">uint32</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::varint, <a class="el" href="structframework_1_1protocol__buffers_1_1varint.html">varint</a>&lt; uint32_t &gt;&gt;</td></tr>
<tr class="memdesc:ac34dbe499be2b9b09d42f19eef4927ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">uint32 primitive. <br/></td></tr>
<tr class="separator:ac34dbe499be2b9b09d42f19eef4927ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09742d5343e38b6992b23d3aa1e72bfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09742d5343e38b6992b23d3aa1e72bfa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a09742d5343e38b6992b23d3aa1e72bfa">uint64</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::varint, <a class="el" href="structframework_1_1protocol__buffers_1_1varint.html">varint</a>&lt; uint64_t &gt;&gt;</td></tr>
<tr class="memdesc:a09742d5343e38b6992b23d3aa1e72bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">uint64 primitive. <br/></td></tr>
<tr class="separator:a09742d5343e38b6992b23d3aa1e72bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfd35f75dbfda7f1c6acef7e2822376"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cfd35f75dbfda7f1c6acef7e2822376"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a1cfd35f75dbfda7f1c6acef7e2822376">sint32</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::varint, <a class="el" href="structframework_1_1protocol__buffers_1_1zig__zag.html">zig_zag</a>&lt; int32_t &gt;&gt;</td></tr>
<tr class="memdesc:a1cfd35f75dbfda7f1c6acef7e2822376"><td class="mdescLeft">&#160;</td><td class="mdescRight">sint32 primitive. <br/></td></tr>
<tr class="separator:a1cfd35f75dbfda7f1c6acef7e2822376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7a843bbcbaa1da9f3e642710f0cbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4d7a843bbcbaa1da9f3e642710f0cbf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ad4d7a843bbcbaa1da9f3e642710f0cbf">sint64</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::varint, <a class="el" href="structframework_1_1protocol__buffers_1_1zig__zag.html">zig_zag</a>&lt; int64_t &gt;&gt;</td></tr>
<tr class="memdesc:ad4d7a843bbcbaa1da9f3e642710f0cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">sint64 primitive. <br/></td></tr>
<tr class="separator:ad4d7a843bbcbaa1da9f3e642710f0cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10ef80bcf588fcfe224ebd4af57125f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac10ef80bcf588fcfe224ebd4af57125f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ac10ef80bcf588fcfe224ebd4af57125f">fixed32</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::fixed_32, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">serializable::little_endian</a>&lt; uint32_t &gt;&gt;</td></tr>
<tr class="memdesc:ac10ef80bcf588fcfe224ebd4af57125f"><td class="mdescLeft">&#160;</td><td class="mdescRight">fixed32 primitive. <br/></td></tr>
<tr class="separator:ac10ef80bcf588fcfe224ebd4af57125f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f07200568b4ed8f7ce49978f2984cbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f07200568b4ed8f7ce49978f2984cbb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a4f07200568b4ed8f7ce49978f2984cbb">fixed64</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::fixed_64, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">serializable::little_endian</a>&lt; uint64_t &gt;&gt;</td></tr>
<tr class="memdesc:a4f07200568b4ed8f7ce49978f2984cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">fixed64 primitive. <br/></td></tr>
<tr class="separator:a4f07200568b4ed8f7ce49978f2984cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad811fc1754af7184270fbd229dec0a0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad811fc1754af7184270fbd229dec0a0f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ad811fc1754af7184270fbd229dec0a0f">sfixed32</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::fixed_32, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">serializable::little_endian</a>&lt; int32_t &gt;&gt;</td></tr>
<tr class="memdesc:ad811fc1754af7184270fbd229dec0a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">sfixed32 primitive. <br/></td></tr>
<tr class="separator:ad811fc1754af7184270fbd229dec0a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164d06bf9231b1dd2e0ed18335f31766"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a164d06bf9231b1dd2e0ed18335f31766"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a164d06bf9231b1dd2e0ed18335f31766">sfixed64</a> = <a class="el" href="structframework_1_1protocol__buffers_1_1wire__type__wrapper.html">wire_type_wrapper</a>&lt; e_wire_type::fixed_64, <a class="el" href="structframework_1_1serializable_1_1little__endian.html">serializable::little_endian</a>&lt; int64_t &gt;&gt;</td></tr>
<tr class="memdesc:a164d06bf9231b1dd2e0ed18335f31766"><td class="mdescLeft">&#160;</td><td class="mdescRight">sfixed64 primitive. <br/></td></tr>
<tr class="separator:a164d06bf9231b1dd2e0ed18335f31766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a52cdb8132ee1d8f72103c6b4b266717a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a52cdb8132ee1d8f72103c6b4b266717a">e_constants</a> { <a class="el" href="namespaceframework_1_1protocol__buffers.html#a52cdb8132ee1d8f72103c6b4b266717aa3f47e9272bd673cba61882e83e897d41">e_constants::fixed_varint_length</a> = 5
 }</td></tr>
<tr class="memdesc:a52cdb8132ee1d8f72103c6b4b266717a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common constants.  <a href="namespaceframework_1_1protocol__buffers.html#a52cdb8132ee1d8f72103c6b4b266717a">More...</a><br/></td></tr>
<tr class="separator:a52cdb8132ee1d8f72103c6b4b266717a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2942a7fb2df9e052dbcd8bc4639febe4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a2942a7fb2df9e052dbcd8bc4639febe4">e_field_type</a> </td></tr>
<tr class="memdesc:a2942a7fb2df9e052dbcd8bc4639febe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field type constants. <br/></td></tr>
<tr class="separator:a2942a7fb2df9e052dbcd8bc4639febe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d08f19f98e5c7cd624c6fc9d54499e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a74d08f19f98e5c7cd624c6fc9d54499e">e_wire_type</a> : uint8_t </td></tr>
<tr class="memdesc:a74d08f19f98e5c7cd624c6fc9d54499e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wire type constants. <br/></td></tr>
<tr class="separator:a74d08f19f98e5c7cd624c6fc9d54499e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a585a9178bfb68a6d708f6bbf24e98927"><td class="memTemplParams" colspan="2"><a class="anchor" id="a585a9178bfb68a6d708f6bbf24e98927"></a>
template&lt;typename Tag , typename Output &gt; </td></tr>
<tr class="memitem:a585a9178bfb68a6d708f6bbf24e98927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a585a9178bfb68a6d708f6bbf24e98927">write_tag</a> (Output &amp;out)</td></tr>
<tr class="memdesc:a585a9178bfb68a6d708f6bbf24e98927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write tag. <br/></td></tr>
<tr class="separator:a585a9178bfb68a6d708f6bbf24e98927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbcf763b93b146e6ab6bb5bc971ca4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="affbcf763b93b146e6ab6bb5bc971ca4d"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:affbcf763b93b146e6ab6bb5bc971ca4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#affbcf763b93b146e6ab6bb5bc971ca4d">write_tag</a> (char *begin, char *end, char *&amp;it)</td></tr>
<tr class="memdesc:affbcf763b93b146e6ab6bb5bc971ca4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write tag. <br/></td></tr>
<tr class="separator:affbcf763b93b146e6ab6bb5bc971ca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97aab34e1cb77ae09880d0e74e1595e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab97aab34e1cb77ae09880d0e74e1595e"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ab97aab34e1cb77ae09880d0e74e1595e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ab97aab34e1cb77ae09880d0e74e1595e">expect_tag</a> (char const *begin, char const *end, char const *&amp;it)</td></tr>
<tr class="memdesc:ab97aab34e1cb77ae09880d0e74e1595e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expect tag. <br/></td></tr>
<tr class="separator:ab97aab34e1cb77ae09880d0e74e1595e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227c7eb6a11a8fd052e6b55bb0b01bd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a227c7eb6a11a8fd052e6b55bb0b01bd6"></a>
template&lt;typename Tag , typename Output &gt; </td></tr>
<tr class="memitem:a227c7eb6a11a8fd052e6b55bb0b01bd6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a227c7eb6a11a8fd052e6b55bb0b01bd6">write_tag</a> (Output &amp;out)</td></tr>
<tr class="memdesc:a227c7eb6a11a8fd052e6b55bb0b01bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write tag. <br/></td></tr>
<tr class="separator:a227c7eb6a11a8fd052e6b55bb0b01bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2142972100676397f14f3b1034865c"><td class="memTemplParams" colspan="2">template&lt;typename SizeFrame , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ace2142972100676397f14f3b1034865c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ace2142972100676397f14f3b1034865c">write_to_string</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:ace2142972100676397f14f3b1034865c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to string.  <a href="#ace2142972100676397f14f3b1034865c">More...</a><br/></td></tr>
<tr class="separator:ace2142972100676397f14f3b1034865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d66c0a4685291115a19618f2ed09b2"><td class="memTemplParams" colspan="2">template&lt;typename SizeFrame , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ac2d66c0a4685291115a19618f2ed09b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ac2d66c0a4685291115a19618f2ed09b2">write_to_frame</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:ac2d66c0a4685291115a19618f2ed09b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to frame.  <a href="#ac2d66c0a4685291115a19618f2ed09b2">More...</a><br/></td></tr>
<tr class="separator:ac2d66c0a4685291115a19618f2ed09b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1da2b8f5445ae8d4dd2952e5202295e"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ad1da2b8f5445ae8d4dd2952e5202295e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ad1da2b8f5445ae8d4dd2952e5202295e">write_to_string_fast</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:ad1da2b8f5445ae8d4dd2952e5202295e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast write to string.  <a href="#ad1da2b8f5445ae8d4dd2952e5202295e">More...</a><br/></td></tr>
<tr class="separator:ad1da2b8f5445ae8d4dd2952e5202295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86f411bbeb7998425dc027829653aa0"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ae86f411bbeb7998425dc027829653aa0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#ae86f411bbeb7998425dc027829653aa0">write_to_string_tight</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:ae86f411bbeb7998425dc027829653aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tight write to string.  <a href="#ae86f411bbeb7998425dc027829653aa0">More...</a><br/></td></tr>
<tr class="separator:ae86f411bbeb7998425dc027829653aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea43edc12d66e9858aed65b702c1e6a8"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:aea43edc12d66e9858aed65b702c1e6a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#aea43edc12d66e9858aed65b702c1e6a8">write_to_frame_fast</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:aea43edc12d66e9858aed65b702c1e6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast write to frame.  <a href="#aea43edc12d66e9858aed65b702c1e6a8">More...</a><br/></td></tr>
<tr class="separator:aea43edc12d66e9858aed65b702c1e6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c5e0df196cea7cd412f7ca827d2ca7"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:aa4c5e0df196cea7cd412f7ca827d2ca7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#aa4c5e0df196cea7cd412f7ca827d2ca7">write_to_frame_tight</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:aa4c5e0df196cea7cd412f7ca827d2ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast write to tight.  <a href="#aa4c5e0df196cea7cd412f7ca827d2ca7">More...</a><br/></td></tr>
<tr class="separator:aa4c5e0df196cea7cd412f7ca827d2ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506d7c8ad47c2aace4eb14068888e107"><td class="memTemplParams" colspan="2">template&lt;typename Input &gt; </td></tr>
<tr class="memitem:a506d7c8ad47c2aace4eb14068888e107"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a506d7c8ad47c2aace4eb14068888e107">write_to_array</a> (Input &amp;&amp;in, char *s, std::size_t &amp;n)</td></tr>
<tr class="memdesc:a506d7c8ad47c2aace4eb14068888e107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to array.  <a href="#a506d7c8ad47c2aace4eb14068888e107">More...</a><br/></td></tr>
<tr class="separator:a506d7c8ad47c2aace4eb14068888e107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23761d13346cd85829a6ad04f225a74"><td class="memTemplParams" colspan="2">template&lt;typename Input &gt; </td></tr>
<tr class="memitem:aa23761d13346cd85829a6ad04f225a74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#aa23761d13346cd85829a6ad04f225a74">write_to_ostream</a> (Input &amp;&amp;in, std::ostream &amp;out)</td></tr>
<tr class="memdesc:aa23761d13346cd85829a6ad04f225a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to ostream.  <a href="#aa23761d13346cd85829a6ad04f225a74">More...</a><br/></td></tr>
<tr class="separator:aa23761d13346cd85829a6ad04f225a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ba8b1fdedd05405c221d43b0ab2415"><td class="memTemplParams" colspan="2">template&lt;typename Output &gt; </td></tr>
<tr class="memitem:a60ba8b1fdedd05405c221d43b0ab2415"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a60ba8b1fdedd05405c221d43b0ab2415">read_from_array</a> (char const *s, std::size_t n, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:a60ba8b1fdedd05405c221d43b0ab2415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from array.  <a href="#a60ba8b1fdedd05405c221d43b0ab2415">More...</a><br/></td></tr>
<tr class="separator:a60ba8b1fdedd05405c221d43b0ab2415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42486c228ccdd4c9a7fd48506e0c4795"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a42486c228ccdd4c9a7fd48506e0c4795"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a42486c228ccdd4c9a7fd48506e0c4795">read_from_string</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:a42486c228ccdd4c9a7fd48506e0c4795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from string.  <a href="#a42486c228ccdd4c9a7fd48506e0c4795">More...</a><br/></td></tr>
<tr class="separator:a42486c228ccdd4c9a7fd48506e0c4795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7597f18435f41ad65afaf3fa6d1ae7b"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:aa7597f18435f41ad65afaf3fa6d1ae7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#aa7597f18435f41ad65afaf3fa6d1ae7b">read_from_frame</a> (Input &amp;&amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:aa7597f18435f41ad65afaf3fa6d1ae7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from frame.  <a href="#aa7597f18435f41ad65afaf3fa6d1ae7b">More...</a><br/></td></tr>
<tr class="separator:aa7597f18435f41ad65afaf3fa6d1ae7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1931a584c203949a0706c5d49075be30"><td class="memTemplParams" colspan="2">template&lt;typename Output &gt; </td></tr>
<tr class="memitem:a1931a584c203949a0706c5d49075be30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a1931a584c203949a0706c5d49075be30">read_from_istream</a> (std::istream &amp;in, Output &amp;&amp;out)</td></tr>
<tr class="memdesc:a1931a584c203949a0706c5d49075be30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from istream.  <a href="#a1931a584c203949a0706c5d49075be30">More...</a><br/></td></tr>
<tr class="separator:a1931a584c203949a0706c5d49075be30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0894f0c4a6eb034912aa2f2de178bc"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size, typename Output &gt; </td></tr>
<tr class="memitem:a4b0894f0c4a6eb034912aa2f2de178bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a4b0894f0c4a6eb034912aa2f2de178bc">fixed_length</a> (std::size_t value, Output &amp;&amp;out)</td></tr>
<tr class="separator:a4b0894f0c4a6eb034912aa2f2de178bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a11d3f2640fe8fa1c85c22496254bcc"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size&gt; </td></tr>
<tr class="memitem:a8a11d3f2640fe8fa1c85c22496254bcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceframework_1_1protocol__buffers.html#a8a11d3f2640fe8fa1c85c22496254bcc">fixed_length</a> (std::size_t value, char *begin, char *end, char *&amp;it)</td></tr>
<tr class="separator:a8a11d3f2640fe8fa1c85c22496254bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Protocol buffers namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af78de9936076af2c5434c75883e1f941"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs , typename Rhs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1protocol__buffers.html#af78de9936076af2c5434c75883e1f941">framework::protocol_buffers::field_less_than</a> = typedef <a class="el" href="namespaceframework.html#a563bad81e0dc0c7eea5ae1377152c08b">value_less_than</a> &lt;<a class="el" href="namespaceframework_1_1protocol__buffers.html#a4cb69b1893c8526b5c7754c626a2f39f">field_number</a> &lt;Lhs&gt;, <a class="el" href="namespaceframework_1_1protocol__buffers.html#a4cb69b1893c8526b5c7754c626a2f39f">field_number</a> &lt;Rhs&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Field less than. </p>
<p>Compares the field number associated to Lhs with that of Rhs. This expression evaluates to std::true_type iff field_number &lt;Lhs&gt;::value &lt; field_number &lt;Rhs&gt;::value - otherwise, evaluates to std::false_type. </p>

</div>
</div>
<a class="anchor" id="afce55ec137daa4abee511e57b290f086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceframework_1_1protocol__buffers.html#afce55ec137daa4abee511e57b290f086">framework::protocol_buffers::is_integer_type</a> = typedef typename detail::is_integer_type_impl &lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is integer type. </p>
<dl class="section note"><dt>Note</dt><dd>Is equivalent to std::true_type for internal integer types only (int32, int64, ...) - used to conditionally enable packed representations of repeated fields. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a52cdb8132ee1d8f72103c6b4b266717a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceframework_1_1protocol__buffers.html#a52cdb8132ee1d8f72103c6b4b266717a">framework::protocol_buffers::e_constants</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common constants. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a52cdb8132ee1d8f72103c6b4b266717aa3f47e9272bd673cba61882e83e897d41"></a>fixed_varint_length</em>&nbsp;</td><td class="fielddoc">
<p>Fixed varint length. </p>
<p>Defines the size of the fixed-length varint used in various implementations to avoid pre-computing the size of a given field.</p>
<dl class="section note"><dt>Note</dt><dd>In the worst case (a very large repeated varint field is a reasonable approximation here) computing the size of the field object may be nearly as expensive as writing the object to a byte string. Here we avoid this cost by fixing the size field to five bytes, limiting the maximum length delimited field size to 2^(5*7)-1 =~ 32 GiB. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4b0894f0c4a6eb034912aa2f2de178bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Size, typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::fixed_length </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a fixed-length varint value to an output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>input value </td></tr>
    <tr><td class="paramname">out</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>varint size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8a11d3f2640fe8fa1c85c22496254bcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2common__macros_8hpp.html#a815d51aeb454eb76481c596c00473a4f">FRAMEWORK_ALWAYS_INLINE</a> bool framework::protocol_buffers::fixed_length </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a fixed-length varint value to a raw character buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>input value </td></tr>
    <tr><td class="paramname">begin</td><td>output buffer begin </td></tr>
    <tr><td class="paramname">end</td><td>output buffer end </td></tr>
    <tr><td class="paramname">it</td><td>final output iterator position </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>varint size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a60ba8b1fdedd05405c221d43b0ab2415"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::read_from_array </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from array. </p>
<p>Deserializes the object from a byte array.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>input byte array </td></tr>
    <tr><td class="paramname">n</td><td>byte array size </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7597f18435f41ad65afaf3fa6d1ae7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::read_from_frame </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from frame. </p>
<p>Deserializes the object from a string through a <a class="el" href="structframework_1_1protocol__buffers_1_1raw__input__frame.html" title="Input frame wrapper.">raw_input_frame</a>. Similar performance considerations as described in write_to_frame_fast hold here.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input string </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1931a584c203949a0706c5d49075be30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::read_from_istream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from istream. </p>
<p>Deserializes the object from a std::istream. This method may be preferred over a <a class="el" href="namespaceframework_1_1serializable.html#a093822d3d91e86e60cc948935e383fec" title="Read forwarder.">serializable::read</a> operation to avoid instantiating multiple templates for istream types.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input istream </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42486c228ccdd4c9a7fd48506e0c4795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::read_from_string </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from string. </p>
<p>Deserializes the object from a string.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input string </td></tr>
    <tr><td class="paramname">out</td><td>output object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a506d7c8ad47c2aace4eb14068888e107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::write_to_array </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to array. </p>
<p>Serializes the object to a fixed-length byte array. The size of the serialized object is stored in n on success.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">s</td><td>output byte array </td></tr>
    <tr><td class="paramname">n</td><td>byte array size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2d66c0a4685291115a19618f2ed09b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFrame , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::write_to_frame </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to frame. </p>
<p>Serializes the object to a string though a raw frame, using a SizeFrame object to asses the object's size.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFrame</td><td>used to assess the object's size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea43edc12d66e9858aed65b702c1e6a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::write_to_frame_fast </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast write to frame. </p>
<p>As write_to_string_fast but writes to the string through a <a class="el" href="structframework_1_1protocol__buffers_1_1raw__input__frame.html" title="Input frame wrapper.">raw_input_frame</a> object. When mixing arbitrary serializable types with protocol buffer specifications the overhead associated with creating an intermediate frame object at each of these transition points was found to be substantial on the compilers benchmarked (clang++ 3.3 - 178146 / g++ 4.7.2 - 20121109). This variant uses a single global frame object for the write rather than a series of local objects - performance implications will be highly workload dependent.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4c5e0df196cea7cd412f7ca827d2ca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::write_to_frame_tight </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast write to tight. </p>
<p>As write_to_string_tight but writes to the string through a <a class="el" href="structframework_1_1protocol__buffers_1_1raw__input__frame.html" title="Input frame wrapper.">raw_input_frame</a> object. When mixing arbitrary serializable types with protocol buffer specifications the overhead associated with creating an intermediate frame object at each of these transition points was found to be substantial on the compilers benchmarked (clang++ 3.3 - 178146 / g++ 4.7.2 - 20121109). This variant uses a single global frame object for the write rather than a series of local objects - performance implications will be highly workload dependent.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa23761d13346cd85829a6ad04f225a74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::write_to_ostream </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to ostream. </p>
<p>Serializes the object to a std::ostream. This method may be preferred over a <a class="el" href="namespaceframework_1_1serializable.html#a8c411f3a0194a69a374492044f2fcea0" title="Write forwarder.">serializable::write</a> operation to avoid instantiating multiple templates for ostream types.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output ostream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace2142972100676397f14f3b1034865c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFrame , typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::write_to_string </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to string. </p>
<p>Serializes the object to a string using a SizeFrame object to asses the object's size.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFrame</td><td>used to assess the object's size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1da2b8f5445ae8d4dd2952e5202295e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::write_to_string_fast </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast write to string. </p>
<p>Serializes the protocol buffer object to a string, using <a class="el" href="classframework_1_1protocol__buffers_1_1max__size__frame.html" title="Size frame.">max_size_frame</a> to asses the object's size. This method can be significantly faster than write_to_array_fast, however the amount of memory allocated to the string may be as much as an order of magnitude more than write_to_array_tight.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae86f411bbeb7998425dc027829653aa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool framework::protocol_buffers::write_to_string_tight </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tight write to string. </p>
<p>Serializes the protocol buffer object to a string, using <a class="el" href="classframework_1_1protocol__buffers_1_1size__frame.html" title="Size frame.">size_frame</a> to assess the object's size. This method uses significantly less memory than write_to_array_fast, however the serialization time may be as much as twice that of write_to_string_fast.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input object </td></tr>
    <tr><td class="paramname">out</td><td>output string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 10 2013 20:49:42 for framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1-20130402
</small></address>
</body>
</html>
